(* ETH Oberon, Copyright 1990-2003 Computer Systems Institute, ETH Zurich, CH-8092 Zurich.
Refer to the license.txt file provided with this distribution. *)

MODULE OFSFATVolumes;	(* be *)

(** write-behind/read-ahead cached OFS.Volume implementation based on Disks. *)
	
(** ATTENTION !! THIS VOLUME MUST NOT BE CACHED USING OFSCacheVolumes.Mod !! *)

IMPORT SYSTEM, Kernel, Modules, Disks, OFS, Unicode;

CONST
	moduleName = "OFSFATVolumes: ";
	Trace = FALSE;
	Detail = Trace & FALSE;
	SystemMove = TRUE;
	
	(** cache types *)
	FAT* = 0;
	Data* = 1;
	
	(* cache default settings *)
	Caching = TRUE;
	FATHashSize = 512; (* number of entries in hash table *)
	FATCacheSizeKB = 256; (* in KBytes *)
	DataHashSize = 256; (* number of entries *)
	DataCacheSizeKB = 1024; (* in KBytes *)
	FlushBufferSize = 256; (* in KBytes *)
	LazyWriting = TRUE;
	
	(** Result values *)
	Ok* = 0;
	Error* = -1; 					(** unknown/unspecified error *)
	ERootFull* = -2;			 (** root directory of FAT12/FAT16 file system full *)
	EInvalidFilename* = -3; (** invalid filename *)
	
	(** FAT Types *)
	FAT12* = 12;
	FAT16* = 16;
	FAT32* = 32;

	(* FSInfo Constants *)
	fsiLeadSig = 41615252H;	
	fsiStrucSig = 61417272H;
	fsiTrailSig = 0AA550000H;
	
	(** FAT Constants *)
	FREE* = 0;
	EOC* = -1;
	BAD* = -2;
	NONE* = -3;
	(* EOC values (end of clusterchain); test for greater or equal *)
	fat12EOC = 0FF8H; 	
	fat16EOC = 0FFF8H;
	fat32EOC = 0FFFFFF8H; 
	(* BAD CLUSTER values; test for equality *)
	fat12BAD = 0FF7H; 
	fat16BAD = 0FFF7H;
	fat32BAD = 0FFFFFF7H; 
	(* FREE CLUSTER *)
	fatFREE = 0;
	
	(** lengths of filenames *)
	MaxUCSNameLen* = 256;			(** maximal length of a filename in Unicode format *)
	MaxUTFNameLen* = 3*MaxUCSNameLen;	(** max length in UTF8 format => every character may be up to 3 bytes long *)
	MaxShortNameLen* = 12;			(** max length of short name in ASCII format *)
	DirEntrySize = 32;						(* size of one physical directory entry *)
	
	(** Directory Entriy Constants *)
	deLAST* = 0X;
	deFREE = 0E5X;
	deFree = 0;
	deLast = 1;
	deVolumeID = 2;
	deFirstLong = 3;
	deLong = 4;
	deShort = 5;
	
	(** File Attributes *)
	faReadOnly* = 0; 
	faHidden* = 1; 
	faSystem* = 2; 
	faVolumeID* = 3; 
	faDirectory* = 4; 
	faArchive* = 5;
	faLongName = { faReadOnly, faHidden, faSystem, faVolumeID };
	
	(* DirCache Types *)
	dcInvalid = -1;
	dcSentinel = 0;
	dcFree = 1;
	dcValid = 2;
	
TYPE
	PCharArray = POINTER TO ARRAY OF CHAR;

	Buffer = POINTER TO RECORD
		adr, index: LONGINT;
		dirty: BOOLEAN;
		nextHash, prevHash, nextLRU, prevLRU: Buffer
	END;
	
	Volume* = POINTER TO RECORD(OFS.Volume)
		dev: Disks.Device;
		partIdx: LONGINT;
		startSector, numSectors: LONGINT;
		IOError*, MountedReadOnly*: BOOLEAN; (** IOError: TRUE iff this volume had I/O errors *)
		data: ARRAY 2 OF POINTER TO ARRAY OF ARRAY OF CHAR;
		hash: ARRAY 2 OF POINTER TO ARRAY OF Buffer;
		getCount, putCount, getHitCount, putHitCount, physicalPutCount: LONGINT;
		lazyWriting: BOOLEAN;
		lru: ARRAY 2 OF Buffer;
		(* FAT specific data *)
		bpb*: BPB; (** Bios Parameter Block *)
		clusterSize: LONGINT; (* to allow local declarations ARRAY vol.clusterSize *)
		unsafe: BOOLEAN; (* if TRUE, Get/PutFATEntry do not validate the cluster number. 
											This flag is reset by every call of Get/PutFATEntry *)
		dirCache: DirCache (* caches the most recently accessed directory *)
	END;
	
	CharArray = ARRAY MAX(LONGINT) OF CHAR;
	
	(** base type for parameter passing via 'EnumerateDirectory' *)
	Param* = POINTER TO ParamDesc;
	ParamDesc* = RECORD
		direntry*: DirEntry;
	END;
	
	TailGenParam = POINTER TO RECORD(ParamDesc)
		short: ShortName;			(* holds the short name *)
		tailmask: SET;					(* defines what tail lengths we are checking *)
		tails: POINTER TO ARRAY OF SET; (* bit-array, if a tail is found the corresponding bit is set  *)
	END;
	
	UpDirParam = POINTER TO RECORD(ParamDesc)
		upCluster, dirCluster: LONGINT;
		found: BOOLEAN;
	END;

	(** File Names *)
	UCSName = ARRAY MaxUCSNameLen OF INTEGER;
	LongName* = ARRAY MaxUTFNameLen OF CHAR;
	ShortName* = ARRAY MaxShortNameLen OF CHAR;
	
	FATTime = RECORD
		time: LONGINT;
		tenth: INTEGER;
	END;
	
	(** client handler called by 'EnumerateDirectory' *)
	EnumDirHandler* = PROCEDURE(p: Param; VAR continue: BOOLEAN);
											
	Address = OFS.Address;
	
	(** BIOS Parameter Block *)
	BPB* = RECORD (* BIOS Parameter Block *)
		jmpBoot*: ARRAY 3 OF CHAR;
		OEMName*: ARRAY 9 OF CHAR; (* including 0X at the end *)
		BytsPerSec*: LONGINT; (* valid values: 512, 1024, 2048, 4096 *)
		SecPerClus*: INTEGER; (* valid values: 1,2,4,8,16,32,64,128 *)
		RsvdSecCnt*: LONGINT; 
		NumFATs*: INTEGER; 
		RootEntCnt*: LONGINT;
		TotSec16*: LONGINT;
		Media*: CHAR; 
		FATSz16*: LONGINT;
		SecPerTrk*: LONGINT;
		NumHeads*: LONGINT;
		HiddSec*: LONGINT;
		TotSec32*: LONGINT;
		VolLab*: ARRAY 12 OF CHAR; (* including 0X at the end *)
		FSInfoSec: LONGINT;
		FSInfo*: FSINFO; (* for FAT12/FAT16 partitions, this has to be initialized *)
		FreeCountValid: BOOLEAN; (* TRUE iff FSInfo.FreeCount equals count of free clusters  *)
		
		(* the following fields are only valid for FAT32 partitions *)
		FATSz32*: LONGINT;
		ExtFlags*: LONGINT;
		FSVer*: RECORD
				Major*, Minor*: CHAR;
			END;
		RootClus*: LONGINT;
		BkBootSec*: LONGINT;
		
		(* addidional information *)
		FATType*: SHORTINT;
		FATSz*: LONGINT;
		RootDirSectors*: LONGINT;
		FirstFATSector*: LONGINT; (* sector number of the start of the first active FAT *)
		FirstDataSector*: LONGINT; (* relative to the start of the partition *)
		CountOfClusters*: LONGINT;
		BytesPerCluster*: LONGINT;
		ActiveFAT*: INTEGER; (* number of active FAT, -1 if all FATs are mirrored at runtime *)
		MirroredFATs*: INTEGER; (* number of active FATs - 1, i.e. 0 if just one FAT is active, 1 if two FATs are active, etc *)
	END;

	FSINFO* =  RECORD (* FAT32 FSnfo Sector *)
		FreeCount*: LONGINT;
		NextFree*: LONGINT;
	END;
	
	DirInfo* = RECORD
		dirCluster*,	(** cluster no. of directory containing this entry *)
		cluster*,		(** no of cluster containing the first physical entry of this entry, -1 if this is a new file *)
		pos*,			(** position in cluster *)
		num*: LONGINT;  (** spans 'num' FAT entries (may cross sector/cluster boundaries) *)
	END;
	
	(** logical Directory entry *)
	DirEntry* = RECORD
		long*: LongName;	(** long filename (UTF-8) *)
		short*: ShortName;	(** short filename (OEM) *)
		namechanged*: BOOLEAN; (** TRUE if the file was renamed *)
		attr*: SET;	(** file attributes *)
		NTRes*: CHAR; (** reserved for use by Windows NT. Set to 0 if the file is created, don't touch it otherwise *)
		modified*: BOOLEAN; (** TRUE if this entry has been modified and needs to be written back to then FAT *)
		size*,	(** size of file *)
		cluster*,	(** first cluster of file *)
		creationDate*, creationTime*, (** all dates/times in Oberon format *)
		accessDate*,
		writeDate*, writeTime*: LONGINT;
		dirInfo*: DirInfo
	END;
	
	DirCache = POINTER TO RECORD
		type: SHORTINT;
		entry: DirEntry;
		next: DirCache;
	END;
	
(**  Cache Handling *)

(** a FAT volume contains two caches: one for the FAT area (including the root directory) and
	one for the data area.
	Buffers in the FAT area are on sector big, the size of those in the data area is equal to the cluster size.
	
	The cache settings can be changed by calling SetCacheSettings. Cache settings can be change seperatly for FAT and data.
	The caches can be in lazy writing mode; this can be controlled using SetCacheMode.
	Dirty buffers can be flushed to disk using the volume's sync command.
	All buffers are flushed at the end of WriteDirectoryEntry (i.e., after calling Files.Register)
*)
(*		
	These procedures were taken from OFSCacheVolumes and modified.	
*)

(* all FAT volumes share one flushBuffer. This buffer is used only during FlushBuffer calls and can thus be shared.
	WARNING: this will not work in a multi tasking environment !!! *)

VAR flushBuffer: PCharArray; 

PROCEDURE FlushBuffer(vol: Volume; cache: SHORTINT; buf: Buffer);
VAR sector, numsectors, res, bufSize, fbPos, lastDirty, i: LONGINT; nextBuf: Buffer;
BEGIN
	IF Detail THEN
		Kernel.WriteString(moduleName); Kernel.WriteString("flushing buffer (type: ");
		Kernel.WriteInt(cache, 0); Kernel.WriteString("; address: "); Kernel.WriteInt(buf.adr, 0); 
		Kernel.WriteChar(")"); Kernel.WriteLn
	END;

	IF Detail THEN Kernel.WriteString("Flush: "); Kernel.WriteLn; Kernel.WriteInt(buf.adr, 7); Kernel.WriteChar("d") END;
	IF (cache = FAT) THEN bufSize := vol.blockSize ELSE bufSize := vol.clusterSize END;
	IF SystemMove THEN
		ASSERT(bufSize <= LEN(flushBuffer));
		SYSTEM.MOVE(SYSTEM.ADR(vol.data[cache, buf.index]), SYSTEM.ADR(flushBuffer[0]), bufSize);
	ELSE
		FOR i := 0 TO bufSize-1 DO
			flushBuffer[i] := vol.data[cache, buf.index, i]
		END
	END;
	fbPos := bufSize; lastDirty := bufSize;
	nextBuf := FindBuffer(vol, cache, buf.adr+1);
	WHILE (nextBuf # NIL) & (fbPos < LEN(flushBuffer)) DO
		IF SystemMove THEN
			ASSERT(bufSize <= LEN(flushBuffer)-fbPos);
			SYSTEM.MOVE(SYSTEM.ADR(vol.data[cache, nextBuf.index]), SYSTEM.ADR(flushBuffer[fbPos]), bufSize);
		ELSE
			FOR i := 0 TO bufSize-1 DO
				flushBuffer[fbPos+i] := vol.data[cache, nextBuf.index, i]
			END
		END;
		INC(fbPos, bufSize);
		IF Detail THEN Kernel.WriteInt(nextBuf.adr, 5) END;
		IF nextBuf.dirty THEN 
			IF Detail THEN Kernel.WriteChar("d") END;
			lastDirty := fbPos; nextBuf.dirty := FALSE
		END;
		IF (fbPos < LEN(flushBuffer)) THEN nextBuf := FindBuffer(vol, cache, nextBuf.adr+1) END
	END;
	IF Detail THEN Kernel.WriteLn END;
	
	IF (cache = FAT) THEN sector := buf.adr ELSE sector := GetFirstSectorOfCluster(vol, buf.adr) END;
	numsectors := lastDirty DIV vol.blockSize;
	IF Detail THEN Kernel.WriteString("  # sectors: "); Kernel.WriteInt(numsectors, 0); Kernel.WriteLn END;
	vol.dev.transfer(vol.dev, Disks.Write, vol.startSector + sector, numsectors, flushBuffer^, 0, res);
	IF (res # 0) THEN SYSTEM.HALT(17) END;
	buf.dirty := FALSE; INC(vol.physicalPutCount)
END FlushBuffer;

PROCEDURE FindBuffer(vol: Volume; cache: SHORTINT; adr: LONGINT): Buffer;
VAR buf: Buffer;
BEGIN
	ASSERT(adr >= 0);
	buf := vol.hash[cache][adr MOD LEN(vol.hash[cache])];
	WHILE (buf # NIL) & (buf.adr # adr) DO buf := buf.nextHash END;
	IF buf # NIL THEN	(* move to end of lru list *)
		buf.prevLRU.nextLRU := buf.nextLRU; buf.nextLRU.prevLRU := buf.prevLRU;
		buf.prevLRU := vol.lru[cache].prevLRU; buf.nextLRU := vol.lru[cache];
		buf.prevLRU.nextLRU := buf; buf.nextLRU.prevLRU := buf
	END;
	RETURN buf
END FindBuffer;

PROCEDURE ReplaceBuffer(vol: Volume; cache: SHORTINT; adr: LONGINT): Buffer;
VAR buf: Buffer; old, new: LONGINT;
BEGIN
	buf := vol.lru[cache]; vol.lru[cache] := vol.lru[cache].nextLRU;	(* re-use buffer and move to end of lru list *)
	IF buf.dirty THEN FlushBuffer(vol, cache, buf) END;
	old := buf.adr MOD LEN(vol.hash[cache]);
	new := adr MOD LEN(vol.hash[cache]);
	buf.adr := adr;
	IF old # new THEN
		(* remove *)
		IF buf.prevHash # NIL THEN
			buf.prevHash.nextHash := buf.nextHash
		ELSE
			vol.hash[cache][old] := buf.nextHash
		END;
		IF buf.nextHash # NIL THEN buf.nextHash.prevHash := buf.prevHash END;
			(* add in front *)
		buf.prevHash := NIL; buf.nextHash := vol.hash[cache][new]; vol.hash[cache][new] := buf;
		IF buf.nextHash # NIL THEN buf.nextHash.prevHash := buf END
	END;
	RETURN buf
END ReplaceBuffer;

(** GetBlock: Addresses > 0 are considered to be cluster numbers whereas addresses < 0 are treated as absolute disk addresses *)
PROCEDURE GetBlock(vol: OFS.Volume; adr: LONGINT; VAR blk: ARRAY OF SYSTEM.BYTE);
VAR buf: Buffer; cache: SHORTINT; sector, numsectors, res, i: LONGINT;
BEGIN
	WITH vol: Volume DO
		INC(vol.getCount);
		IF (adr > 0) THEN
			ASSERT((adr >= 2) & (adr <= vol.bpb.CountOfClusters+1));
			cache := Data; sector := GetFirstSectorOfCluster(vol, adr); numsectors := vol.bpb.SecPerClus
		ELSIF (adr < 0) THEN
			adr := -adr;
			ASSERT(adr < vol.bpb.FirstDataSector);
			cache := FAT; sector := adr; numsectors := 1; 
		ELSE (* read block 0: BPB *)
			ASSERT(vol.dev.blockSize <= LEN(blk));
			vol.dev.transfer(vol.dev, Disks.Read, vol.startSector, 1, SYSTEM.VAL(CharArray, blk), 0, res);
			RETURN
		END;
		IF Caching THEN
			buf := FindBuffer(vol, cache, adr);
			IF buf # NIL THEN	(* copy from cache *)
				INC(vol.getHitCount);
				IF SystemMove THEN
					ASSERT(vol.blockSize*numsectors <= LEN(blk));
					SYSTEM.MOVE(SYSTEM.ADR(vol.data[cache, buf.index,0]), SYSTEM.ADR(blk[0]), vol.blockSize*numsectors)
				ELSE
					FOR i := 0 TO vol.blockSize*numsectors-1 DO
						blk[i] := vol.data[cache, buf.index,i]
					END
				END
			ELSE	(* replace a buffer *)
				ASSERT(vol.dev.blockSize * numsectors <= LEN(blk));
				vol.dev.transfer(vol.dev, Disks.Read, vol.startSector + sector, numsectors, SYSTEM.VAL(CharArray, blk), 0, res);
				IF (res # 0) THEN SYSTEM.HALT(17) END; (* trap 17: disk error *)
				buf := ReplaceBuffer(vol, cache, adr);
				IF SystemMove THEN
					ASSERT(vol.blockSize*numsectors <= (LEN(vol.data[cache])-buf.index)*LEN(vol.data[cache,0]));
					SYSTEM.MOVE(SYSTEM.ADR(blk[0]), SYSTEM.ADR(vol.data[cache, buf.index,0]), vol.blockSize*numsectors)
				ELSE
					FOR i := 0 TO vol.blockSize*numsectors-1 DO
						vol.data[cache, buf.index,i] := CHR(blk[i])
					END
				END
			END
		ELSE
			ASSERT(vol.dev.blockSize * numsectors <= LEN(blk));
			vol.dev.transfer(vol.dev, Disks.Read, vol.startSector + sector, numsectors, SYSTEM.VAL(CharArray, blk), 0, res);
			IF (res # 0) THEN SYSTEM.HALT(17) END (* trap 17: disk error *)
		END
	END
END GetBlock;

(** PutBlock: Addresses > 0 are considered to be cluster numbers whereas addresses < 0 are treated as absolute disk addresses *)
PROCEDURE PutBlock(vol: OFS.Volume; adr: LONGINT; VAR blk: ARRAY OF SYSTEM.BYTE);
VAR buf: Buffer; cache: SHORTINT; sector, numsectors, i, res: LONGINT;
BEGIN
	IF (Disks.ReadOnly IN vol.flags) THEN ErrorMsg("volume is write protected"); SYSTEM.HALT(21) END;
	WITH vol: Volume DO
		INC(vol.putCount);
		ASSERT(adr # 0); (* writing block 0 is not allowed *)
		IF (adr > 0) THEN
			cache := Data;
			sector := GetFirstSectorOfCluster(vol, adr); numsectors := vol.bpb.SecPerClus
		ELSIF (adr < 0) THEN
			cache := FAT;
			sector := -adr; numsectors := 1; adr := -adr
		END;
		IF Caching THEN
			buf := FindBuffer(vol, cache, adr);
			IF buf # NIL THEN INC(vol.putHitCount)
			ELSE buf := ReplaceBuffer(vol, cache, adr)
			END;
			(* refresh data *)
			IF SystemMove THEN
				ASSERT(vol.blockSize*numsectors <= (LEN(vol.data[cache])-buf.index)*LEN(vol.data[cache,0]));
				SYSTEM.MOVE(SYSTEM.ADR(blk[0]), SYSTEM.ADR(vol.data[cache, buf.index,0]), vol.blockSize*numsectors);
			ELSE
				FOR i := 0 TO vol.blockSize*numsectors-1 DO
					vol.data[cache, buf.index,i] := CHR(blk[i])
				END
			END;
			IF ~vol.lazyWriting THEN FlushBuffer(vol, cache, buf)
			ELSE buf.dirty := TRUE
			END
		ELSE
			ASSERT(vol.dev.blockSize * numsectors <= LEN(blk));
			vol.dev.transfer(vol.dev, Disks.Write, vol.startSector + sector, numsectors, SYSTEM.VAL(CharArray, blk), 0, res);
			IF (res # 0) THEN SYSTEM.HALT(17) END
		END
	END
END PutBlock;

(** Available - returns the number of free blocks (=sectors) *)
PROCEDURE Available(vol: OFS.Volume): LONGINT;
VAR c, free: LONGINT;
BEGIN
	WITH vol: Volume DO
		IF vol.bpb.FreeCountValid THEN free := vol.bpb.FSInfo.FreeCount
		ELSE
			free := 0;
			FOR c := 2 TO vol.bpb.CountOfClusters+1 DO
				IF (GetFATEntry(vol, c) = FREE) THEN INC(free) END
			END;
			vol.bpb.FSInfo.FreeCount := free;
			vol.bpb.FreeCountValid := TRUE
		END;
		RETURN free*vol.bpb.SecPerClus
	END
END Available;

(** Write back any cached information to the volume. *)
PROCEDURE Sync*(vol: OFS.Volume);
VAR type: SHORTINT; buf: Buffer; i: LONGINT; cnt: ARRAY 2 OF LONGINT;
BEGIN
	WITH vol: Volume DO
		cnt[FAT] := 0; cnt[Data] := 0;
		FOR type := 0 TO 1 DO
			IF (vol.hash[type] # NIL) THEN
				FOR i := 0 TO LEN(vol.hash[type])-1 DO
					buf := vol.hash[type, i];
					WHILE (buf # NIL) DO
						IF buf.dirty THEN FlushBuffer(vol, type, buf); INC(cnt[type]) END;
						buf := buf.nextHash
					END
				END
			END
		END
	END;
	IF Trace THEN
		Kernel.WriteString(moduleName); Kernel.WriteString("Sync: "); Kernel.WriteInt(cnt[FAT], 0); 
		Kernel.WriteString(" FAT buffers, "); Kernel.WriteInt(cnt[Data], 0); Kernel.WriteString(" data buffers written"); 
		Kernel.WriteLn
	END
END Sync;

(** Finalize - finalizes a volume (i.e. flushes all modified buffers) and closes its device *)
PROCEDURE Finalize(vol: OFS.Volume);
VAR res: LONGINT;
BEGIN
	WITH vol: Volume DO
		IF ~(Disks.ReadOnly IN vol.flags) THEN
			WriteFSInfoSector(vol);		
			WriteVolumeFlags(vol, TRUE, FALSE)
		END;
		Sync(vol);
		Disks.Unmount(vol.dev, vol.partIdx);
		Disks.Close(vol.dev, res);	(* ignore res *)
		vol.dev := NIL;
		vol.partIdx := -1;
		vol.startSector := MAX(LONGINT);
		OFS.FinalizeVol(vol)
	END
END Finalize;


(**  Volume Initialization  *)

(** New - Generate a new disk volume object. OFS.Par: device ["#" part] [",R"] [",X"] *)
PROCEDURE New*;
VAR name: Disks.Name; dirty, readonly, override: BOOLEAN;  i, res: LONGINT;  part: INTEGER;
	dev: Disks.DeviceTable; vol: Volume;
BEGIN
	OFS.NewVol := NIL; readonly := FALSE; Kernel.SetLogMark;
	GetParams(name, part, readonly, override);
	IF (name # "") THEN 
		CheckDiskette(name);
		Disks.GetRegistered(dev);
		IF (dev # NIL) THEN
			Kernel.WriteString(moduleName); Kernel.WriteString(name);
			i := 0; WHILE (i # LEN(dev)) & (dev[i].name # name) DO INC(i) END;
			IF (i # LEN(dev)) THEN
				Disks.Open(dev[i], res);
				IF (res = Disks.Ok) THEN
					Kernel.WriteChar("#"); Kernel.WriteInt(part, 1); Kernel.WriteChar(" ");
					IF (part < LEN(dev[i].table)) THEN
						Disks.Mount(dev[i], part, res);
						IF (res = Disks.Ok) THEN
							NEW(vol);
							IF readonly THEN INCL(vol.flags, Disks.ReadOnly)  END;
							vol.dev := dev[i]; COPY(vol.dev.name, vol.name);
							OFS.AppendStr("#", vol.name); OFS.AppendInt(part, vol.name);
							vol.partIdx := part;
							vol.startSector := dev[i].table[part].start;
							vol.numSectors := dev[i].table[part].size;
							vol.size := vol.numSectors;
							vol.blockSize := dev[i].blockSize;
							vol.Available := Available;
							vol.GetBlock := GetBlock; vol.PutBlock := PutBlock;
							vol.Sync := Sync;
							vol.Finalize := Finalize;
							vol.MountedReadOnly := readonly;
							IF Caching THEN
								SetCacheSize(vol, FAT, 11, 32); (* a valid FAT cache is necessary for ReadBPB *)
							END;
							IF ReadBPB(vol) THEN
								IF ~IsOberonBootDisk(vol) THEN
									IF ~IsOberonFileSystem(vol) THEN
										IF (vol.bpb.FSVer.Major = 0X) & (vol.bpb.FSVer.Minor = 0X) THEN			
											vol.clusterSize := vol.bpb.BytesPerCluster;
											IF Caching THEN
												SetCacheSize(vol, FAT, FATHashSize, FATCacheSizeKB);
												SetCacheSize(vol, Data, DataHashSize, DataCacheSizeKB);
												SetCacheMode(vol, LazyWriting);
											END;
											IF ~VolumeIsClean(vol) THEN 
												dirty := TRUE; 
												IF ~override THEN INCL(vol.flags, Disks.ReadOnly) END
											END;
											vol.size := (vol.bpb.CountOfClusters+1)*vol.bpb.SecPerClus;
											WriteVolumeFlags(vol, FALSE, FALSE);
											NEW(vol.dirCache); vol.dirCache.type := dcInvalid;
											Kernel.WriteString("mounted");
											IF (Disks.ReadOnly IN vol.flags) THEN Kernel.WriteString(" (read-only)") END;
											IF dirty THEN
												Kernel.WriteLn;
												Kernel.WriteString("   This volume was not properly unmounted or had disk I/O errors."); Kernel.WriteLn;
												Kernel.WriteString("   Please run a disk repair utility program under MS-DOS."); Kernel.WriteLn;
												IF ~override THEN Kernel.WriteString("   The volume is mounted read-only.")
												ELSE Kernel.WriteString("   WARNING: readonly protection overridden ! Data may be lost !")
												END;
												Kernel.WriteLn
											END;
											OFS.NewVol := vol
										ELSE
											Kernel.WriteLn;
											Kernel.WriteString("  This FAT32 file system driver was designed for version 0.0, "); Kernel.WriteLn;
											Kernel.WriteString("  The device contains a FAT32 file system, version "); Kernel.WriteInt(ORD(vol.bpb.FSVer.Major), 0);
											Kernel.WriteChar("."); Kernel.WriteInt(ORD(vol.bpb.FSVer.Minor), 0)
										END
									ELSE Kernel.WriteString("contains an Oberon file system")
									END
								ELSE Kernel.WriteString("is an Oberon boot device")
								END
							ELSE Kernel.WriteString("can not read Bios Parameter Block")
							END;
							IF (OFS.NewVol = NIL) THEN Disks.Unmount(dev[i], part) END
						ELSE Kernel.WriteString("already mounted")
						END
					ELSE Kernel.WriteString("not found")
					END				
				ELSE Kernel.WriteString("error "); Kernel.WriteInt(res, 1)
				END;
				IF (OFS.NewVol = NIL) THEN Disks.Close(dev[i], res) END
			ELSE Kernel.WriteString("not found")
			END;
			Kernel.WriteLn
		END
	END
END New;

(** SetCacheSize - set the cache size. 'cache' is either 'FAT' or 'Data'. [hashSize]=elements, [cacheSize]=kiloBytes*)
PROCEDURE SetCacheSize*(vol: Volume; cache: SHORTINT; hashSize, cacheSizeKB: LONGINT);
VAR bufSize, cacheSize, i, n: LONGINT; buf: Buffer;
BEGIN
	Sync(vol);
	IF (cache = FAT) THEN bufSize := vol.blockSize
	ELSE bufSize := vol.blockSize*vol.bpb.SecPerClus
	END;
	cacheSize := cacheSizeKB * 1024 DIV bufSize; 
	NEW(vol.data[cache], cacheSize, bufSize);
	NEW(vol.hash[cache], hashSize);
	FOR i := 0 TO hashSize-1 DO vol.hash[cache, i] := NIL END;
	NEW(vol.lru[cache]); vol.lru[cache].nextLRU:= vol.lru[cache]; vol.lru[cache].prevLRU := vol.lru[cache];	(* dummy *)
	FOR i := 0 TO cacheSize-1 DO
		NEW(buf); buf.adr := -i; buf.index := i; buf.dirty := FALSE;
		n := buf.adr MOD LEN(vol.hash[cache]);
		buf.prevHash := NIL; buf.nextHash := vol.hash[cache, n]; vol.hash[cache, n] := buf;
		IF buf.nextHash # NIL THEN buf.nextHash.prevHash := buf END;
		buf.prevLRU := vol.lru[cache].prevLRU; buf.nextLRU := vol.lru[cache];
		buf.prevLRU.nextLRU := buf; buf.nextLRU.prevLRU := buf
	END;
	vol.lru[cache].prevLRU.nextLRU := vol.lru[cache].nextLRU; vol.lru[cache].nextLRU.prevLRU := vol.lru[cache].prevLRU;	(* remove dummy *)
	vol.lru[cache] := vol.lru[cache].nextLRU
END SetCacheSize;

(** GetCacheSize - returns the cache size. 'cache' is either 'FAT' or 'Data'. [hashSize]=elements, [cacheSize]=kiloBytes *)
PROCEDURE GetCacheSize*(vol: Volume; cache: SHORTINT; VAR hashSize, cacheSize: LONGINT);
BEGIN hashSize := LEN(vol.hash[cache]); cacheSize := LEN(vol.data[cache]) DIV 1024
END GetCacheSize;

(** SetCacheMode - enable/disable lazy writing *)
PROCEDURE SetCacheMode*(vol: Volume; lazyWriting: BOOLEAN);
BEGIN
	vol.lazyWriting := lazyWriting;
	IF ~lazyWriting THEN Sync(vol) END
END SetCacheMode;

(** GetCacheMode - returns TRUE if lazy writing is enabled, FALSE otherwise *)
PROCEDURE GetCacheMode*(vol: Volume): BOOLEAN;
BEGIN RETURN vol.lazyWriting
END GetCacheMode;

(** GetCacheStatistics - returns the cache performance counters *)
PROCEDURE GetCacheStatistics*(vol: Volume; VAR getCount, getHitCount, putCount, putHitCount, physicalPutCount: LONGINT);
BEGIN
	getCount := vol.getCount; getHitCount := vol.getHitCount; 
	putCount := vol.putCount; putHitCount := vol.putHitCount; 
	physicalPutCount := vol.physicalPutCount
END GetCacheStatistics;

(* GetParams - get the params from OFS.Mod *)
PROCEDURE GetParams(VAR device: ARRAY OF CHAR; VAR part: INTEGER; VAR ReadOnly, Override: BOOLEAN);
VAR ch: CHAR; i: LONGINT; stop: BOOLEAN;
BEGIN
	(* parameter: dev#par [,R] [,X] *)
	REPEAT OFS.ReadPar(ch) UNTIL (ch # " ");
	i := 0;
	WHILE (ch # 0X) & (ch # "#") DO device[i] := ch;  INC(i);  OFS.ReadPar(ch) END;
	device[i] := 0X;
	part := 0;
	OFS.ReadPar(ch);
	WHILE (ch >= "0") & (ch <= "9") DO
		part := 10*part + (ORD(ch) - ORD("0"));
		OFS.ReadPar(ch)
	END;
	
	stop := FALSE; ReadOnly := FALSE; Override := FALSE;
	REPEAT
		CASE ch OF
		| " " : 
		| "," : OFS.ReadPar(ch); 
			IF (ch = "R") THEN ReadOnly := TRUE
			ELSIF (ch = "X") THEN Override := TRUE
			ELSE stop := TRUE
			END
		ELSE stop := TRUE
		END;
		OFS.ReadPar(ch)
	UNTIL stop
		
	(*WHILE (ch = " ") DO OFS.ReadPar(ch) END;
	IF (ch = ",") THEN
		REPEAT
			OFS.ReadPar(ch);
			IF (ch = "R") THEN ReadOnly := TRUE END
			IF (ch
		UNTIL (ch < " ") OR (ch = "~")
	END*)
END GetParams;

(* CheckDiskette - installs the floppy disk as a device if 'name' starts with "Diskette" *)
PROCEDURE CheckDiskette(name: ARRAY OF CHAR);
VAR m: Modules.Module; c: Modules.Command;
BEGIN
	name[8] := 0X;	(* assume large enough *)
	IF name = "Diskette" THEN
		m := Modules.ThisMod("Diskettes");
		IF m # NIL THEN
			c := Modules.ThisCommand(m, "Install");
			IF c # NIL THEN c() END
		END
	END
END CheckDiskette;

(** FAT Initialization *)

(* ReadBPB - reads the BIOS parameter block of partition 'vol.part' from 'vol.dev' and fills the 'vol.bpb' parameter *)
PROCEDURE ReadBPB(vol: Volume): BOOLEAN;
VAR b: ARRAY vol.blockSize OF CHAR; TotSec, DataSec: LONGINT;
BEGIN
	GetBlock(vol, 0, b);
	GetCharacters(b, 0, vol.bpb.jmpBoot, 3);
	GetCharacters(b, 3, vol.bpb.OEMName, 8); vol.bpb.OEMName[8] := 0X;
	vol.bpb.BytsPerSec := GetUnsignedInteger(b, 11);
	vol.bpb.SecPerClus := ORD(b[13]);
	vol.bpb.RsvdSecCnt := GetUnsignedInteger(b, 14);
	vol.bpb.NumFATs := ORD(b[16]);
	vol.bpb.RootEntCnt := GetUnsignedInteger(b, 17);
	vol.bpb.TotSec16 := GetUnsignedInteger(b, 19);
	vol.bpb.Media := b[21];
	vol.bpb.FATSz16 := GetUnsignedInteger(b, 22);
	vol.bpb.SecPerTrk := GetUnsignedInteger(b, 24);
	vol.bpb.NumHeads := GetUnsignedInteger(b, 26);
	vol.bpb.HiddSec := GetLongint(b, 28);
	vol.bpb.TotSec32 := GetLongint(b, 32);
	vol.bpb.FATSz32 := GetLongint(b, 36);
	vol.bpb.FSInfo.FreeCount := 0; (* unknown for FAT12/FAT16 *)
	vol.bpb.FSInfo.NextFree := 2; (* by default start searching at cluster 2 *)
	
	IF ~(((vol.bpb.jmpBoot[0] = 0EBX) & (vol.bpb.jmpBoot[2] = 090X)) OR (vol.bpb.jmpBoot[0] = 0E9X)) THEN 
		RETURN FALSE
	END;
	IF (vol.blockSize # vol.bpb.BytsPerSec) OR (vol.blockSize MOD DirEntrySize # 0) THEN
		ErrorMsg("Invalid block size"); RETURN FALSE
	END;
	
	(* determine FAT type *)
	IF (vol.bpb.TotSec16 # 0) THEN TotSec := vol.bpb.TotSec16 ELSE TotSec := vol.bpb.TotSec32 END;
	vol.bpb.RootDirSectors := ((vol.bpb.RootEntCnt * 32) + (vol.blockSize-1)) DIV vol.blockSize; (* round up *)
	IF (vol.bpb.FATSz16 # 0) THEN vol.bpb.FATSz := vol.bpb.FATSz16 ELSE vol.bpb.FATSz := vol.bpb.FATSz32 END;
	vol.bpb.FirstDataSector := vol.bpb.RsvdSecCnt + (vol.bpb.NumFATs * vol.bpb.FATSz) + vol.bpb.RootDirSectors;
	DataSec := TotSec - (vol.bpb.RsvdSecCnt + (vol.bpb.NumFATs * vol.bpb.FATSz) + vol.bpb.RootDirSectors);
	vol.bpb.CountOfClusters := DataSec DIV vol.bpb.SecPerClus;
	vol.bpb.BytesPerCluster := vol.bpb.SecPerClus * vol.blockSize;
	
	IF (vol.bpb.CountOfClusters < 4085) THEN vol.bpb.FATType := FAT12
	ELSIF (vol.bpb.CountOfClusters < 65525) THEN vol.bpb.FATType := FAT16
	ELSE vol.bpb.FATType := FAT32
	END;
	
	vol.bpb.ActiveFAT := -1;
	vol.bpb.MirroredFATs := vol.bpb.NumFATs-1;
	vol.bpb.FirstFATSector := vol.bpb.RsvdSecCnt;
	vol.bpb.FreeCountValid := FALSE;
	IF (vol.bpb.FATType # FAT32) THEN
		GetCharacters(b, 43, vol.bpb.VolLab, 11); vol.bpb.VolLab[11] := 0X;
		vol.bpb.FATSz32 := 0
		(* the FSInfo structure is missing in FAT12/16 *)
	ELSE
		vol.bpb.FATSz32 := GetLongint(b, 36);
		vol.bpb.ExtFlags := GetUnsignedInteger(b, 40);
		IF (AND(vol.bpb.ExtFlags, 80H) = 80H) THEN
			(* only one FAT is active, it is the one referenced in bits 0-3 *)
			vol.bpb.ActiveFAT := SHORT(AND(vol.bpb.ExtFlags, 0FH));
			IF (vol.bpb.ActiveFAT >= vol.bpb.NumFATs) THEN
				Kernel.WriteString(" bios parameter block error");
				RETURN FALSE
			END;
			vol.bpb.MirroredFATs := 0; 
			IF (vol.bpb.FATType = FAT16) THEN INC(vol.bpb.FirstFATSector, vol.bpb.ActiveFAT*vol.bpb.FATSz16)
			ELSE INC(vol.bpb.FirstFATSector, vol.bpb.ActiveFAT*vol.bpb.FATSz32)
			END
		END;
		vol.bpb.FSVer.Major := b[42];
		vol.bpb.FSVer.Minor := b[43];
		vol.bpb.RootClus := GetLongint(b, 44);
		vol.bpb.BkBootSec := GetUnsignedInteger(b, 50);
		GetCharacters(b, 71, vol.bpb.VolLab, 11); vol.bpb.VolLab[11] := 0X;
		vol.bpb.FSInfoSec := GetUnsignedInteger(b, 48);
		ReadFSInfoSector(vol)	
	END;
	RETURN TRUE
END ReadBPB;

(* ReadFSInfoSector - reads the FSInfo sector (FAT32 volumes only) *)
PROCEDURE ReadFSInfoSector(vol: Volume);
VAR b: ARRAY vol.blockSize OF CHAR;
BEGIN
	IF (vol.bpb.FATType = FAT32) THEN
		vol.GetBlock(vol, -vol.bpb.FSInfoSec, b);
		IF (GetLongint(b, 0) = fsiLeadSig) & (GetLongint(b, 484) = fsiStrucSig) & (GetLongint(b, 508) = fsiTrailSig) THEN
			vol.bpb.FSInfo.FreeCount := GetLongint(b, 488);
			vol.bpb.FSInfo.NextFree := GetLongint(b, 492);
			vol.bpb.FreeCountValid := TRUE
		ELSE
			Kernel.WriteString(" (warning: wrong FSInfo sector signature)")
		END		
	END
END ReadFSInfoSector;

(* WriteFSInfoSector - writes the FSInfo sector (FAT32 volumes only) *)
PROCEDURE WriteFSInfoSector(vol: Volume);
VAR b: ARRAY vol.blockSize OF CHAR;
BEGIN
	IF (vol.bpb.FATType = FAT32) THEN
		vol.GetBlock(vol, -vol.bpb.FSInfoSec, b);
		IF (GetLongint(b, 0) = fsiLeadSig) & (GetLongint(b, 484) = fsiStrucSig) & (GetLongint(b, 508) = fsiTrailSig) THEN
			PutLongint(b, 488, vol.bpb.FSInfo.FreeCount);
			PutLongint(b, 492, vol.bpb.FSInfo.NextFree);
			vol.PutBlock(vol, -vol.bpb.FSInfoSec, b)
		END		
	END
END WriteFSInfoSector;

(* IsOberonBootDisk - checks if a 'FAT12' file system has the OEM id set to 'OBERON' *)
PROCEDURE IsOberonBootDisk(vol: Volume): BOOLEAN;
BEGIN RETURN vol.bpb.OEMName = "OBERON"
END IsOberonBootDisk;

(* IsOberonFileSystem - checks if a 'FAT12' file system has the first byte of the root directory set to 0FFX.
	This method is used in Diskette.OpenVol to determine if a floppy disk contains an Oberon file system *)
PROCEDURE IsOberonFileSystem(vol: Volume): BOOLEAN;
VAR buf: ARRAY vol.blockSize OF CHAR; dirStart: LONGINT;
BEGIN
	IF (vol.bpb.FATType = FAT12) THEN
		dirStart := vol.bpb.RsvdSecCnt + (vol.bpb.NumFATs * vol.bpb.FATSz16);
		GetBlock(vol, -dirStart, buf);
		RETURN buf[0] = 0FFX
	ELSE RETURN FALSE
	END
END IsOberonFileSystem;

(* VolumeIsClean - checks two bits in FAT entry 1: CleanShutdown and IOError
	returns TRUE if both bits are 1
	file system drivers set CleanShutdown to 1 if the volume was properly unmounted
	IOError is set to 0 if the file system drivers encountered disk read/write errors *)
PROCEDURE VolumeIsClean(vol: Volume): BOOLEAN;
VAR EOCMark, BitMask: SET;
BEGIN
	IF (vol.bpb.FATType # FAT12) THEN
		vol.unsafe := TRUE;
		EOCMark := SYSTEM.VAL(SET, GetFATEntry(vol, 1));
		IF (vol.bpb.FATType = FAT16) THEN BitMask := {15, 14} 
		ELSE BitMask := {31, 30}
		END;
		RETURN (EOCMark * BitMask = BitMask)
	ELSE RETURN TRUE
	END	
END VolumeIsClean;

(* WriteVolumeFlags - if the volume is not mounted readonly, sets the two bits in FAT entry 1: CleanShutdown and IOError. *)
PROCEDURE WriteVolumeFlags(vol: Volume; CleanShutdown, IOError: BOOLEAN);
VAR EOCMark: SET;
BEGIN
	IF ~(Disks.ReadOnly IN vol.flags) & (vol.bpb.FATType # FAT12) THEN
		vol.unsafe := TRUE;
		EOCMark := SYSTEM.VAL(SET, GetFATEntry(vol, 1));
		IF (vol.bpb.FATType = FAT16) THEN
			IF CleanShutdown THEN INCL(EOCMark, 15) ELSE EXCL(EOCMark, 15) END;
			IF ~IOError THEN INCL(EOCMark, 14) ELSE EXCL(EOCMark, 14) END
		ELSE
			IF CleanShutdown THEN INCL(EOCMark, 31) ELSE EXCL(EOCMark, 31) END;
			IF ~IOError THEN INCL(EOCMark, 30) ELSE EXCL(EOCMark, 30) END
		END;
		vol.unsafe := TRUE;
		PutFATEntry(vol, 1, SYSTEM.VAL(LONGINT, EOCMark))
	END
END WriteVolumeFlags;

(** File Allocation Table  Handling  *)

(** GetFATEntry - reads an entry at index 'cluster' from the active FAT *)
PROCEDURE GetFATEntry*(vol: Volume; cluster: LONGINT): LONGINT;
VAR data: ARRAY vol.blockSize OF CHAR; unsafe: BOOLEAN; FAT12Buffer: ARRAY 2 OF CHAR;
	FATOffset, ThisFATSecNum, ThisFATEntOffset, res: LONGINT;
BEGIN
	unsafe := vol.unsafe; vol.unsafe := FALSE;
	IF (cluster = EOC) OR (cluster = BAD) OR (~unsafe & ((cluster < 2) OR (cluster > vol.bpb.CountOfClusters+1))) THEN
		Kernel.WriteInt(cluster, 0); ErrorMsg(": bad cluster number"); SYSTEM.HALT(15)
	END;
	
	IF (vol.bpb.FATType = FAT12) THEN	
		FATOffset := cluster + cluster DIV 2;
		ThisFATSecNum := vol.bpb.FirstFATSector + (FATOffset DIV vol.blockSize);
		ThisFATEntOffset := FATOffset MOD vol.blockSize;
		
		vol.GetBlock(vol, -ThisFATSecNum, data);
		FAT12Buffer[0] := data[ThisFATEntOffset];
		IF (ThisFATEntOffset = vol.blockSize-1) & (ThisFATSecNum # vol.bpb.FirstDataSector-1) THEN
			(* this FAT entry spans a sector boundary in the FAT *)
			vol.GetBlock(vol, -(ThisFATSecNum+1), data); 
			FAT12Buffer[1] := data[0]
		ELSE 
			FAT12Buffer[1] := data[ThisFATEntOffset+1]
		END;
		
		res := GetUnsignedInteger(FAT12Buffer, 0);
		IF ODD(cluster) THEN res := SYSTEM.LSH(res, -4) (* get the high 12 bits *)
		ELSE res := AND(res, 0FFFH) (* get the low 12 bits *)
		END;
		
		IF ~unsafe THEN 
			IF (res >= fat12EOC) THEN res := EOC
			ELSIF (res = fat12BAD) THEN res := BAD
			END
		END	
	ELSE (* FAT16/FAT32 *)
		IF (vol.bpb.FATType = FAT16) THEN FATOffset := cluster*2 
		ELSE FATOffset := cluster*4
		END;
		ThisFATSecNum := vol.bpb.FirstFATSector + (FATOffset DIV vol.blockSize);
		ThisFATEntOffset := FATOffset MOD vol.blockSize;
		

		vol.GetBlock(vol, -ThisFATSecNum, data);
		IF (vol.bpb.FATType = FAT16) THEN
			res := GetUnsignedInteger(data, ThisFATEntOffset);
			IF ~unsafe THEN 
				IF (res >= fat16EOC) THEN res := EOC
				ELSIF (res = fat16BAD) THEN res := BAD
				END
			END
		ELSE (* FAT32 *)		
			res := GetLongint(data, ThisFATEntOffset);
			IF ~unsafe THEN 
				res := AND(res, 0FFFFFFFH);
				IF (res >= fat32EOC) THEN res := EOC
				ELSIF (res = fat32BAD) THEN res := BAD
				END
			END
		END
	END;
	RETURN res
END GetFATEntry;

(** PutFATEntry - writes 'link' to entry 'cluster' into the active FAT or all FATs if they are mirrored at runtime *)
PROCEDURE PutFATEntry*(vol: Volume; cluster, link: LONGINT);
VAR data: ARRAY vol.blockSize OF CHAR; unsafe: BOOLEAN; FAT12Buffer: ARRAY 2 OF CHAR;
	FATOffset, ThisFATSecNum, ThisFATEntOffset, fatIdx, res: LONGINT;
BEGIN
	unsafe := vol.unsafe; vol.unsafe := FALSE;
	IF (cluster = BAD) OR (~unsafe & ((cluster < 2) OR (cluster > vol.bpb.CountOfClusters+1)) OR 
		(~unsafe & (link # FREE) & (link # EOC) & ((link < 2) OR (link > vol.bpb.CountOfClusters+1)))) THEN 
		ErrorMsg("Bad cluster number"); SYSTEM.HALT(15)
	END;

	IF (vol.bpb.FATType = FAT12) THEN
		IF ~unsafe THEN
			IF (link = FREE) THEN link := fatFREE
			ELSIF (link = EOC) THEN link := fat12EOC
			END
		END;
			
		FATOffset := cluster + cluster DIV 2;
		ThisFATSecNum := vol.bpb.FirstFATSector + (FATOffset DIV vol.blockSize);
		ThisFATEntOffset := FATOffset MOD vol.blockSize;
		
		vol.GetBlock(vol, -ThisFATSecNum, data);
		FAT12Buffer[0] := data[ThisFATEntOffset];
		IF (ThisFATEntOffset = vol.blockSize-1) & (ThisFATSecNum # vol.bpb.FirstDataSector-1) THEN
			(* this FAT entry spans a sector boundary in the FAT *)
			vol.GetBlock(vol, -(ThisFATSecNum+1), data);
			FAT12Buffer[1] := data[0]
		ELSE
			FAT12Buffer[1] := data[ThisFATEntOffset+1]
		END;
				
    	res := GetUnsignedInteger(FAT12Buffer, 0);
		IF ODD(cluster) THEN (* set the high 12 bits, preserve the low 4 bits *)
			PutInteger(FAT12Buffer, 0, SHORT(SYSTEM.LSH(link, 4) + AND(res, 0FH)))
		ELSE (* set the low 12 bits, preserve the high 4 bits *)
			PutInteger(FAT12Buffer, 0, SHORT(AND(res, 0F000H) + link))
		END;		
		
		vol.GetBlock(vol, -ThisFATSecNum, data);
		data[ThisFATEntOffset] := FAT12Buffer[0];
		IF (ThisFATEntOffset = vol.blockSize-1) & (ThisFATSecNum # vol.bpb.FirstDataSector-1) THEN
			(* this FAT entry spans a sector boundary in the FAT *)
			FOR fatIdx := 0 TO vol.bpb.MirroredFATs DO
				vol.PutBlock(vol, -ThisFATSecNum, data);
				INC(ThisFATSecNum, vol.bpb.FATSz)
			END;
			ThisFATSecNum := vol.bpb.FirstFATSector + (FATOffset DIV vol.blockSize)+1;
			vol.GetBlock(vol, -ThisFATSecNum, data);
			data[0] := FAT12Buffer[1]
		ELSE
			data[ThisFATEntOffset+1] := FAT12Buffer[1]
		END;

		FOR fatIdx := 0 TO vol.bpb.MirroredFATs DO
			vol.PutBlock(vol, -ThisFATSecNum, data);
			INC(ThisFATSecNum, vol.bpb.FATSz)
		END
	ELSE (* FAT16/FAT32 *)
		IF ~unsafe THEN
			IF (link = FREE) THEN link := fatFREE
			ELSIF (link = EOC) THEN 
				IF (vol.bpb.FATType = FAT16) THEN link := fat16EOC ELSE link := fat32EOC END
			END
		END;
		IF (vol.bpb.FATType = FAT16) THEN FATOffset := cluster*2 
		ELSE FATOffset := cluster*4
		END;
		ThisFATSecNum := vol.bpb.FirstFATSector + (FATOffset DIV vol.blockSize);
		ThisFATEntOffset := FATOffset MOD vol.blockSize;
		vol.GetBlock(vol, -ThisFATSecNum, data); (* copy same block to all mirrored fats *)
		FOR fatIdx := 0 TO vol.bpb.MirroredFATs DO
			IF (vol.bpb.FATType = FAT16) THEN
				PutInteger(data, ThisFATEntOffset, SHORT(link))
			ELSE (* FAT32: preserve the high 4 bits, set the low 28 bits *)
				IF unsafe THEN PutLongint(data, ThisFATEntOffset, link)
				ELSE
					res := GetLongint(data, ThisFATEntOffset);
					PutLongint(data, ThisFATEntOffset, AND(res, 0F0000000H) + link)
				END
			END;
			vol.PutBlock(vol, -ThisFATSecNum, data);
			INC(ThisFATSecNum, vol.bpb.FATSz)
		END
	END
END PutFATEntry;

(** AllocateCluster - searches a free cluster and links it with 'cluster'. If the disk is full, a trap is raised *)
PROCEDURE AllocateCluster*(vol: Volume; cluster: LONGINT): LONGINT;
VAR clus, res, cnt: LONGINT;
BEGIN
	clus := vol.bpb.FSInfo.NextFree;
	res := GetFATEntry(vol, clus); cnt := 1;
	WHILE (res # FREE) & (cnt < vol.bpb.CountOfClusters) DO
		INC(clus); IF (clus = vol.bpb.CountOfClusters+2) THEN clus := 2 END;
		INC(cnt);
		res := GetFATEntry(vol, clus)
	END;
	IF (res = FREE) THEN 
		IF (clus < vol.bpb.CountOfClusters+1) THEN  vol.bpb.FSInfo.NextFree := clus+1
		ELSE vol.bpb.FSInfo.NextFree := 2
		END;
		IF (cluster # NONE) THEN 
			PutFATEntry(vol, cluster, clus) 
		END;
		PutFATEntry(vol, clus, EOC);
		DEC(vol.bpb.FSInfo.FreeCount);
		RETURN clus
	ELSE SYSTEM.HALT(16) (* disk full *)
	END
END AllocateCluster;

(** GetFirstSectorOfCluster - returns the sector number of the first sector of cluster 'cluster' *)
PROCEDURE GetFirstSectorOfCluster*(vol: Volume; cluster: LONGINT): LONGINT;
BEGIN RETURN ((cluster-2) * vol.bpb.SecPerClus) + vol.bpb.FirstDataSector
END GetFirstSectorOfCluster;

(** GetClusterOfSector - returns the cluster sector belongs to *)
PROCEDURE GetClusterOfSector*(vol: Volume; sector: LONGINT): LONGINT;
BEGIN RETURN (sector - vol.bpb.FirstDataSector) DIV vol.bpb.SecPerClus + 2
END GetClusterOfSector;

(** GetNextSector - returns the next cluster/sector pair for a given cluster/sector combination
	If it is the last sector of a cluster chain, then 'sector' is set to -1 and 'cluster' remains unchanged *)
PROCEDURE GetNextSector*(vol: Volume; VAR cluster, sector: LONGINT);
VAR firstSector, nextCluster : LONGINT;
BEGIN
	IF (cluster < 2) OR (cluster > vol.bpb.CountOfClusters+1) THEN ErrorMsg("Bad cluster number"); SYSTEM.HALT(17) END;
	firstSector := GetFirstSectorOfCluster(vol, cluster);
	IF (sector = -1) THEN sector := firstSector
	ELSIF (sector - firstSector < vol.bpb.SecPerClus-1) THEN INC(sector)
	ELSE (* first sector of next cluster *)
		nextCluster := GetFATEntry(vol, cluster);
		IF (nextCluster >= 2) & (nextCluster <= vol.bpb.CountOfClusters+1) THEN 
			cluster := nextCluster;
			sector := GetFirstSectorOfCluster(vol, cluster)
		ELSIF (nextCluster = EOC) THEN sector := -1
		ELSE ErrorMsg("Error in cluster chain"); SYSTEM.HALT(17)
		END
	END
END GetNextSector;


(** Directory Enumeration *)

PROCEDURE GetDirectoryCluster*(vol: Volume; directory: LONGINT; cluster: LONGINT; VAR data: ARRAY OF CHAR): LONGINT;
VAR firstSector, lastSector, sector, i, k, j: LONGINT; block: ARRAY vol.blockSize OF CHAR;
BEGIN
	IF (directory = 0) & (vol.bpb.FATType # FAT32) THEN (* root directory of FAT12/16 *)
		firstSector := vol.bpb.RsvdSecCnt + (vol.bpb.NumFATs * vol.bpb.FATSz16);
		lastSector := firstSector + vol.bpb.RootEntCnt DIV (vol.blockSize DIV DirEntrySize) - 1;
		sector := firstSector + (cluster * vol.bpb.SecPerClus);
		FOR i := 0 TO vol.bpb.SecPerClus-1 DO
			IF (sector + i <= lastSector) THEN
				GetBlock(vol, -(sector + i), block);
				IF SystemMove THEN
					ASSERT(vol.blockSize <= LEN(data)-i*vol.blockSize);
					SYSTEM.MOVE(SYSTEM.ADR(block[0]), SYSTEM.ADR(data[i*vol.blockSize]), vol.blockSize)
				ELSE
					FOR j := 0 TO vol.blockSize-1 DO
						data[i*vol.blockSize+j] := block[j]
					END
				END
			ELSE 
				FOR k := 0 TO vol.blockSize-1 DO data[i*vol.blockSize+k] := 0X END
			END
		END;
		RETURN cluster+1
	ELSE
		IF (directory = 0) & (cluster = 0) THEN cluster := vol.bpb.RootClus END;
		GetBlock(vol, cluster, data);
		RETURN GetFATEntry(vol, cluster)
	END
END GetDirectoryCluster;

PROCEDURE PutDirectoryCluster(vol: Volume; directory, cluster: LONGINT; VAR data: ARRAY OF CHAR): LONGINT;
VAR firstSector, lastSector, sector, i, k, j: LONGINT; block: ARRAY vol.blockSize OF CHAR;
BEGIN
	IF (directory = 0) & (vol.bpb.FATType # FAT32) THEN (* root directory of FAT12/16 *)
		firstSector := vol.bpb.RsvdSecCnt + (vol.bpb.NumFATs * vol.bpb.FATSz16);
		lastSector := firstSector + vol.bpb.RootEntCnt DIV (vol.blockSize DIV DirEntrySize) - 1;
		sector := firstSector + (cluster * vol.bpb.SecPerClus);
		FOR i := 0 TO vol.bpb.SecPerClus-1 DO
			IF (sector + i <= lastSector) THEN
				IF SystemMove THEN
					ASSERT(vol.blockSize <= LEN(block));
					SYSTEM.MOVE(SYSTEM.ADR(data[i*vol.blockSize]), SYSTEM.ADR(block[0]), vol.blockSize);
				ELSE
					FOR j := 0 TO vol.blockSize-1 DO
						block[j] := data[i*vol.blockSize+j]
					END
				END;
				PutBlock(vol, -(sector + i), block)
			ELSE
				FOR k := 0 TO (vol.blockSize DIV DirEntrySize)-1 DO
					IF (data[i*vol.blockSize+k*DirEntrySize] # deLAST) THEN (* writing past the end of the root directory traps *)
						ErrorMsg("Root directory overflow"); HALT(20)
					END
				END						
			END
		END;
		RETURN cluster + 1
	ELSE
		IF (directory = 0) & (cluster = 0) THEN cluster := vol.bpb.RootClus END;
		PutBlock(vol, cluster, data);
		RETURN GetFATEntry(vol, cluster)
	END
END PutDirectoryCluster;

(* ExtractLongName - extracts and returns the long name in one physical directory entry, converted to UTF-8 *)
PROCEDURE ExtractLongName(VAR buf: ARRAY OF CHAR; pos: LONGINT; VAR s: ARRAY OF CHAR);
VAR k: INTEGER; ucs4: ARRAY 14 OF LONGINT;
BEGIN
	FOR k := 0 TO 4 DO ucs4[k] := GetUnsignedInteger(buf, pos + 1 + 2*k) END;
	FOR k := 0 TO 5 DO ucs4[k+5] := GetUnsignedInteger(buf, pos + 14 + 2*k) END;
	FOR k := 0 TO 1 DO ucs4[k+11] := GetUnsignedInteger(buf, pos + 28 + 2*k) END;
	ucs4[13] := 0;
	Unicode.UCS4toUTF8(ucs4, s)
END ExtractLongName;

(* CheckSum - calculates the checksum for a short name. The short name starts at position 'pos' in 'b' *)
PROCEDURE CheckSum(VAR b: ARRAY OF CHAR; pos: LONGINT): CHAR;
VAR sum, i: INTEGER;
BEGIN
	sum := 0;
	FOR i := 0 TO 10 DO
		IF ODD(sum) THEN sum := 80H + sum DIV 2
		ELSE sum := sum DIV 2
		END;
		sum := (sum + ORD(b[pos+i])) MOD 256
	END;
	RETURN CHR(sum MOD 256)
END CheckSum;

(* GetDirectoryEntry - reads one physical directory entry from 'b' at position 'pos' and returns its contents in 'direntry' *)
PROCEDURE GetDirectoryEntry*(FATType: SHORTINT; VAR b: ARRAY OF CHAR; pos: LONGINT; VAR direntry: DirEntry; VAR chksum: CHAR;
	VAR index: INTEGER): INTEGER;
VAR ch: CHAR; res, i : INTEGER; ft: FATTime;
BEGIN
	ch := b[pos];
	IF (ch = deFREE) THEN res := deFree
	ELSIF (ch = deLAST) THEN res := deLast
	ELSE
		IF (b[pos] = 05X) THEN b[pos] := 0EFX END;
		direntry.attr := SYSTEM.VAL(SET, b[pos+11]) * {0,1,2,3,4,5,6,7};
		IF (direntry.attr * faLongName = faLongName) THEN
			index := ORD(b[pos]);
			IF (AND(index, 40H) # 0) THEN index := SHORT(AND(3FH, index)); res := deFirstLong
			ELSE res := deLong
			END;
			ExtractLongName(b, pos, direntry.long);				
			chksum := b[pos+13]
		ELSE (* short name or volume entry *)
			FOR i := 0 TO 10 DO direntry.short[i] := b[pos+i] END; direntry.short[11] := 0X;
			IF (faVolumeID IN direntry.attr) THEN res := deVolumeID
			ELSE
				direntry.NTRes := b[pos+12];
				IF (FATType = FAT32) THEN direntry.cluster := GetUnsignedInteger(b, pos+20) * 10000H
				ELSE direntry.cluster := 0
				END;
				direntry.cluster := direntry.cluster + GetUnsignedInteger(b, pos+26);
				IF ~(faDirectory IN direntry.attr) & (direntry.cluster = 0) THEN direntry.cluster := NONE END;
				direntry.size := GetLongint(b, pos+28);
				direntry.creationDate := DateFAT2Oberon(GetUnsignedInteger(b, pos+16));
				ft.time := GetUnsignedInteger(b, pos+14);
				ft.tenth := ORD(b[pos+13]) MOD 200 DIV 100;
				direntry.creationTime := TimeFAT2Oberon(ft);
				direntry.accessDate := DateFAT2Oberon(GetUnsignedInteger(b, pos+18));
				direntry.writeDate := DateFAT2Oberon(GetUnsignedInteger(b, pos+24));
				ft.time := GetUnsignedInteger(b, pos+22); ft.tenth := 0;
				direntry.writeTime := TimeFAT2Oberon(ft);
				res := deShort
			END
		END
	END;
	RETURN res
END GetDirectoryEntry;

PROCEDURE NewDirCacheEntry(VAR dirCache: DirCache; type: SHORTINT; dirCluster, cluster, pos, num: LONGINT);
BEGIN
	IF (dirCache.type # dcInvalid) THEN
		IF (dirCache.next = NIL) THEN NEW(dirCache.next) END; (* recycle to reduce GC overhead *)
		dirCache := dirCache.next
	END;
	dirCache.type := type;
	dirCache.entry.dirInfo.dirCluster := dirCluster;
	dirCache.entry.dirInfo.cluster := cluster;
	dirCache.entry.dirInfo.pos := pos;
	dirCache.entry.dirInfo.num := num
END NewDirCacheEntry;

(* ProcessDirectoryCluster - concatenates single physical directory entries to one logical entry and calls 'handler' *)
PROCEDURE ProcessDirectoryCluster(vol: Volume; VAR dirCache: DirCache; VAR lastFree: BOOLEAN; 
	dirCluster, cluster: LONGINT; VAR b: ARRAY OF CHAR;  VAR direntry: DirEntry;  VAR longidx: INTEGER; VAR chksum: CHAR): BOOLEAN;
VAR pde: DirEntry; long: LongName; index, i, k, n, m, res: INTEGER; cs: CHAR; stop: BOOLEAN;
BEGIN
	i := 0;
	REPEAT
		res := GetDirectoryEntry(vol.bpb.FATType, b, DirEntrySize*i, pde, cs, index);
		IF (res = deFree) THEN
			IF ~lastFree THEN NewDirCacheEntry(dirCache, dcFree, dirCluster, cluster, i*DirEntrySize, 1)
			ELSE INC(dirCache.entry.dirInfo.num)
			END;
			lastFree := TRUE
		ELSIF (res = deLast) THEN
			IF ~lastFree THEN NewDirCacheEntry(dirCache, dcSentinel, dirCluster, cluster, i*DirEntrySize, -1)
			ELSE dirCache.type := dcSentinel; dirCache.entry.dirInfo.num := -1
			END;
			dirCache.next := NIL;
			stop := TRUE
		ELSE
			lastFree := FALSE;
			CASE res OF
			| deVolumeID :
			| deFirstLong : 
					longidx := index; chksum := cs; direntry.long := pde.long; 					
					direntry.dirInfo.dirCluster := dirCluster; direntry.dirInfo.cluster := cluster; 
					direntry.dirInfo.pos := i*DirEntrySize; direntry.dirInfo.num := longidx + 1 (* including the short entry *)
			| deLong :
					IF (index = longidx-1) & (cs = chksum) THEN
						DEC(longidx);
						n := 0; WHILE(pde.long[n] # 0X) DO long[n] := pde.long[n]; INC(n) END;
						m := 0; WHILE (direntry.long[m] # 0X) DO long[n] := direntry.long[m]; INC(n); INC(m) END;
						direntry.long := long; direntry.long[n] := 0X
					ELSE longidx := -1; direntry.long := "" (* ignore long name *)
					END
			| deShort :
					long := direntry.long;
					pde.dirInfo := direntry.dirInfo; direntry := pde;
					IF (long = "") OR (CheckSum(b, DirEntrySize*i) # chksum) THEN
						(* no long name or checksum does not match: discard long name and copy short name into long name *)
						FOR n := 0 TO 7 DO long[n] := pde.short[n] END;
						WHILE (long[n-1] = " ") DO DEC(n) END;
						IF (pde.short[8] # " ") OR (pde.short[9] # " ") OR (pde.short[10] # " ") THEN
							long[n] := "."; INC(n);
							FOR k := 8 TO 10 DO long[n] := pde.short[k]; INC(n) END;
							WHILE (long[n-1] = " ") DO DEC(n) END;
						END;
						long[n] := 0X;
						direntry.dirInfo.dirCluster := dirCluster; direntry.dirInfo.cluster := cluster; 
						direntry.dirInfo.pos := i*DirEntrySize; direntry.dirInfo.num := 1
					END;
					direntry.long := long;
					NewDirCacheEntry(dirCache, dcValid, -1, -1, -1, -1);
					dirCache.entry := direntry;
					direntry.long := ""
			END
		END;
		INC(i)
	UNTIL (i = vol.clusterSize DIV DirEntrySize) OR stop;
	RETURN ~stop
END ProcessDirectoryCluster;

(* EnumerateDirectory - enumerates the contens of a directory identified by its first cluster *)
PROCEDURE EnumerateDirectory*(vol: Volume; directory: LONGINT; handler: EnumDirHandler; param: Param);
VAR direntry: DirEntry; cluster, dirCluster, nextCluster: LONGINT; longidx: INTEGER; continue, lastFree: BOOLEAN;
	chksum: CHAR; data: ARRAY vol.clusterSize OF CHAR; dirCache: DirCache;
BEGIN
	IF Trace THEN
		Kernel.WriteString(moduleName); Kernel.WriteString("EnumerateDirectory "); Kernel.WriteInt(directory, 0); 
		Kernel.WriteLn
	END;
	chksum := 0X; longidx := 0;
	IF (directory = 0) & (vol.bpb.FATType = FAT32) THEN dirCluster := vol.bpb.RootClus (* FAT32 root directory *)
	ELSE dirCluster := directory
	END;
	
	IF (vol.dirCache.type = dcInvalid) OR (vol.dirCache.entry.dirInfo.dirCluster # dirCluster) THEN
		dirCache := vol.dirCache; dirCache.type := dcInvalid; dirCache.entry.dirInfo.dirCluster := directory;
		continue := TRUE; lastFree := TRUE; nextCluster := dirCluster;
		REPEAT
			cluster := nextCluster;
			nextCluster := GetDirectoryCluster(vol, dirCluster, cluster, data);
		UNTIL ~ProcessDirectoryCluster(vol, dirCache, lastFree, directory, cluster,  data, direntry, longidx, chksum) OR (nextCluster = -1);
				
		(* fix sentinel *)
		IF (cluster < 0) THEN 
			(* the directory does not contain a deLAST mark because the last entry in the last sector is not free *)
			IF Detail THEN Kernel.WriteString(" adding sentinel"); Kernel.WriteLn END;
			NewDirCacheEntry(dirCache, dcSentinel, dirCluster, -cluster, 0, -1)
		END;		
		IF Detail THEN DumpDirCache(vol) END
	END;
	dirCache := vol.dirCache; continue := TRUE;
	
	IF (handler # NIL) THEN
		WHILE (dirCache # NIL) & (dirCache.type # dcSentinel) & continue DO
			IF (dirCache.type = dcValid) THEN
				param.direntry := dirCache.entry;
				handler(param, continue);
			END;
			dirCache := dirCache.next
		END
	END
END EnumerateDirectory;

(* Writing Directory Entries *)

(* ValidShortChar - checks if a char 'ch' at position 'i' in a short name is valid *)
PROCEDURE ValidShortChar(ch: CHAR; pos: INTEGER): BOOLEAN;
VAR lossy: BOOLEAN;
BEGIN
	(* invalid characters (in order of appearance):  < " ", """, "*", "+", ",", ".", "/", ":", ";", "<", "=", ">", "?", "[", "\", "]", "|" *)
	IF ((ch >= 20X) & (ch # 22X) & (~((ch >= 2AX) & (ch <= 2CX))) & (ch # 2EX) & (ch # 2FX) & (~((ch >= 3AX) & (ch <= 3FX))) &
		(~((ch >= 5BX) & (ch <= 5DX))) & (ch # 7CX)) OR ((ch = 05X) & (pos = 0)) THEN
		RETURN Unicode.UpperCh(ch, lossy) = ch
	ELSE RETURN FALSE
	END
END ValidShortChar;

(* IsShortName - checks if a long name 'l' could be stored in a short name entry *)
PROCEDURE IsShortName(l: LongName): BOOLEAN;
VAR s: ARRAY 12 OF CHAR; i, estart: INTEGER; lossy: BOOLEAN;
BEGIN
	IF (l = ".") OR (l = "..") THEN RETURN TRUE
	ELSIF Unicode.UTF8toASCII(l, s, lossy)  & ~lossy THEN
		i := 0;
		WHILE (i < 11) & (s[i] # 0X) & ValidShortChar(s[i], i) DO INC(i) END;
		IF (s[i] = ".") & (i < 8) THEN
			INC(i); estart := i;
			WHILE ValidShortChar(s[i], i) DO INC(i) END;
			RETURN (s[i] = 0X) & (i - estart <= 3)
		ELSE RETURN (s[i] = 0X)
		END
	END;
	RETURN FALSE
END IsShortName;

(* TailGeneration - generates a short name that does not collides with an existing long or short name *)
PROCEDURE TailGenHandler(p: Param; VAR continue: BOOLEAN);
VAR i,k: INTEGER;
	tail,idx,ofs,offset,delta: LONGINT;
BEGIN
	WITH p: TailGenParam DO
		continue := TRUE;
		(* compare names *)
		i := 0; WHILE (i < 8) & (p.direntry.short[i] = p.short[i]) DO INC(i) END;
		k := 8; WHILE (k < 11) & (p.direntry.short[k] = p.short[k]) DO INC(k) END;
		IF (k = 11) THEN
			IF (i = 8) THEN INCL(p.tails[0], 0) (* identical filename *)
			ELSE
				IF (p.direntry.short[i] = "~") THEN
					(* extract tail value and calculate offset in bit array *)
					tail := 0; k := i+1; offset := 0; delta := 1;
					WHILE (k < 8) & (p.direntry.short[k] >= "0") & (p.direntry.short[k] <= "9") DO
						tail := 10*tail + ORD(p.direntry.short[k]) - ORD("0");
						IF ~(k-i-1 IN p.tailmask) THEN (* k-i-1 is the length of the tail - 1 *)
							(* ajust offset to bit-array *)
							offset := offset - delta + delta DIV 10 
						END; 
						delta := delta * 10;
						INC(k)
					END;
					(* set bit in bitmask *)
					IF (k-i-1 IN p.tailmask) THEN	(* k-i-1 is the length of the tail *)
						(* check tail range. If the tail is outside the range we can ignore it since we won't generate a conflicting tail *)
						IF (delta DIV 10 <= tail) & (tail < delta) THEN
							idx := (offset + tail) DIV 32;
							ofs := (offset + tail) MOD 32;
							INCL(p.tails[idx], ofs)
						END;
						RETURN
					END;
				END
			END
		END
	END
END TailGenHandler;

PROCEDURE TailFinder(vol: Volume; directory: Address; p: TailGenParam; VAR tail: LONGINT): BOOLEAN;
VAR delta,i,idx,l,ofs,offset,rlow,t: LONGINT;
BEGIN
	(* calculate size of bit-array and initialize it *)
	offset := 1; delta := 10;
	FOR l := 1 TO 6 DO
		IF (l IN p.tailmask) THEN offset := offset + delta - (delta DIV 10) END;
		delta := delta * 10
	END;
	NEW(p.tails, (offset + 31) DIV 32);
	FOR i := 0 TO LEN(p.tails)-1 DO p.tails[i] := {} END;

	(* seach directory *)	
	INCL(p.tailmask, 0);
	EnumerateDirectory(vol, directory, TailGenHandler, p);
	
	(* try to find a free tail number *)
	tail := 0;
	IF (0 IN p.tails[0]) THEN
		rlow := 1; (* range is rlow....10*rlow-1 *)
		delta := 10; offset := 0;
		FOR l := 1 TO  6 DO
			IF (l IN p.tailmask) THEN
				FOR t := offset+rlow TO offset+10*rlow-1 DO
					idx := t DIV 32;
					ofs := t MOD 32;
					IF ~(ofs IN p.tails[idx]) THEN 
						(* we have found a free tail number, exit *)
						tail := t - offset; RETURN TRUE
					END
				END
			ELSE
				offset := offset - delta;
			END;
			delta := delta * 10;
			rlow := rlow * 10
		END
	ELSE RETURN TRUE
	END;
	RETURN FALSE
END TailFinder;

PROCEDURE TailGeneration(vol: Volume; directory: Address; VAR shortname: ShortName; TailNeeded: BOOLEAN);
VAR tp: TailGenParam; l, len, max, pos, tail: LONGINT;
BEGIN
	IF Detail THEN
		Kernel.WriteString(moduleName); Kernel.WriteString("Tail Generation for '"); 
		Kernel.WriteString(shortname); Kernel.WriteChar("'"); Kernel.WriteLn
	END;
	NEW(tp);
	tp.short := shortname;
	(* first, we look for tails with lengths 1,2 or 3 (~x, ~xx, ~xxx) *)
	tp.tailmask := {1, 2, 3};
	IF ~TailFinder(vol, directory, tp, tail) THEN
		(* now look at each tail length seperately *)
		l := 4;
		REPEAT
			tp.tailmask := {l};
			INC(l)
		UNTIL TailFinder(vol, directory, tp, tail) OR (l = 7)
	END;
	IF TailNeeded OR (0 IN tp.tails[0]) THEN
		IF (tail = 0) & TailNeeded THEN tail := 1 END;
		IF (tail # 0) THEN (* tail found *)
			(* calc length of tail *)
			len := 1; max := 10; WHILE (max-1 < tail) DO max := max*10; INC(len) END;
			(* insert tail, avoid spaces in short name *)
			pos := 7-len;
			WHILE (pos > 0) & (shortname[pos-1] = " ") DO DEC(pos) END;
			shortname[pos] := "~";
			WHILE (len > 0) DO
				shortname[pos+len] := CHR(ORD("0") + tail MOD 10);
				tail := tail DIV 10;
				DEC(len)
			END	
		ELSE 
			(* argh, all possible tails (= 1111105 !) occupied. Raise "You are a Moron" exception *)
			Kernel.WriteString(moduleName); Kernel.WriteString("Too many files with similar names"); 
			Kernel.WriteLn; SYSTEM.HALT(20)
		END
	END;
	IF Detail THEN Kernel.WriteString(" name: '"); Kernel.WriteString(shortname); Kernel.WriteChar("'"); Kernel.WriteLn END 
END TailGeneration;

(* GetShortName - returns a valid short name for a given long name and a directory *)
PROCEDURE GetShortName(vol: Volume; VAR direntry: DirEntry; VAR unicode: UCSName; VAR res: INTEGER);
VAR extPos, i,k, n: LONGINT; ascii: ARRAY 256 OF CHAR; l, lossy: BOOLEAN;
BEGIN
	IF Trace THEN
		Kernel.WriteString(moduleName); Kernel.WriteString("GetShortName ("); Kernel.WriteString(direntry.long);
		Kernel.WriteString("')"); Kernel.WriteLn
	END;
	res := Ok;
	(* calculate the number of physical directory entries needed to store the new name *)
	IF ~IsShortName(direntry.long) THEN
		FOR i := 0 TO 255 DO unicode[i] := -1 END; (* = 0FFFFH *)
		n := 0;
		IF Unicode.UTF8toUCS2(direntry.long, unicode, n) THEN direntry.dirInfo.num := SHORT((n-1 + 12) DIV 13 + 1)
		ELSE ErrorMsg("Filename too long"); SYSTEM.HALT(17)
		END
	ELSE (* short name only *)
		FOR i := 0 TO 10 DO direntry.short[i] := " " END; direntry.short[11] := 0X;
		i := 0;
		WHILE (direntry.long[i] # 0X) & (direntry.long[i] # ".") DO direntry.short[i] := direntry.long[i]; INC(i) END;
		IF (direntry.long[i] = ".") THEN
			extPos := SHORT(i+1); i := 0;
			WHILE (direntry.long[extPos+i] # 0X) DO direntry.short[8+i] := direntry.long[extPos+i]; INC(i) END
		END;
		direntry.dirInfo.num := 1
	END;
	
	IF (direntry.dirInfo.num > 1) THEN
		(* generate short name *)
		(* step 1-4: convert name to upper case OEM (ASCII), set 'lossy conversion'-flag, strip leading and embedded spaces, strip leading periods.
			also remember, if the long name has an extension and the position of its first character *)
		IF ~Unicode.UTF8toASCII(direntry.long, ascii, lossy) THEN res := EInvalidFilename; RETURN END;
		i := 0; k := 0; extPos := -1;
		WHILE (i < 256) & (ascii[i] # 0X) DO
			ascii[k] := Unicode.UpperCh(ascii[i], l);
			IF l THEN ascii[k] := "_"; lossy := TRUE END;
			IF (ascii[k] # " ") & ((ascii[k] # ".") OR (k > 0)) THEN INC(k) END;
			IF (ascii[k] = ".") THEN extPos := -1;
			ELSIF (ascii[k] # ".") & (ascii[k-1] = ".") THEN extPos := SHORT(k)
			END;
			INC(i)
		END;
		IF Detail THEN
			Kernel.WriteString(" UTF8 -> ASCII: '"); Kernel.WriteString(ascii); Kernel.WriteString("'; lossy = "); 
			IF lossy THEN Kernel.WriteString("TRUE") ELSE Kernel.WriteString("FALSE") END
		END;
		(* step 5: copy primary portion of name *)
		FOR i := 0 TO 10 DO direntry.short[i] := " " END; direntry.short[11] := 0X;
		i := 0;
		WHILE (ascii[i] # 0X) & (ascii[i] # ".") & (i < 8) DO direntry.short[i] := ascii[i]; INC(i) END;
		(* step 6: omitted *)
		(* step 7: copy extension *)
		IF (extPos # -1) THEN
			i := 0;
			WHILE (ascii[extPos + i] # 0X) & (i < 3) DO direntry.short[8+i] := ascii[extPos+i]; INC(i) END
		END;
		IF Detail THEN
			Kernel.WriteString(" extracted short name: '"); Kernel.WriteString(direntry.short);
			Kernel.WriteChar("'"); Kernel.WriteLn
		END;
			
		(* numeric tail generation *)
		TailGeneration(vol, direntry.dirInfo.dirCluster, direntry.short, lossy);
	END;
	IF Trace THEN
		Kernel.WriteString(moduleName); Kernel.WriteString("GetShortName: short name is '"); Kernel.WriteString(direntry.short); 
		Kernel.WriteChar("'"); Kernel.WriteLn
	END
END GetShortName;

(** RemoveDirectoryEntry - removes an existing directory entry from the FAT.
	The logical entry may span several physical entries *)
PROCEDURE RemoveDirectoryEntry*(vol: Volume; VAR direntry: DirEntry; VAR res: INTEGER);
VAR cluster, dummy, nextCluster, pos, i: LONGINT; data: ARRAY vol.clusterSize OF CHAR; p, c: DirCache;
BEGIN
	IF (direntry.dirInfo.cluster # -1) THEN
		cluster := direntry.dirInfo.cluster;
		dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
		pos := direntry.dirInfo.pos;
		FOR i := 0 TO direntry.dirInfo.num-1 DO
			data[pos] := 0E5X;
			INC(pos, DirEntrySize);
			IF (i < direntry.dirInfo.num-1) & (pos = vol.clusterSize) THEN
				pos := 0;
				nextCluster := PutDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
				dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, nextCluster, data);
				cluster := nextCluster
			END
		END;
		dummy := PutDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
		
		(* update dirCache *)
		IF (vol.dirCache.type # dcInvalid) & (direntry.dirInfo.dirCluster = vol.dirCache.entry.dirInfo.dirCluster) THEN
			p := NIL; c := vol.dirCache;
			WHILE (c.type # dcSentinel) & ((c.entry.dirInfo.cluster # direntry.dirInfo.cluster) OR (c.entry.dirInfo.pos # direntry.dirInfo.pos)) DO
				p := c; c := c.next
			END;
			IF (c.type # dcSentinel) THEN c.type := dcFree ELSE SYSTEM.HALT(15) END;
			IF Trace THEN
				Kernel.WriteString(moduleName); Kernel.WriteString("RemoveDirectoryEntry "); Kernel.WriteInt(direntry.dirInfo.cluster, 0); 
				Kernel.WriteChar("@"); Kernel.WriteInt(direntry.dirInfo.pos, 0); Kernel.WriteChar("."); Kernel.WriteInt(direntry.dirInfo.num, 0); 
				Kernel.WriteLn;
				IF Detail THEN DumpDirCache(vol) END
			END
		END;
		(* invalidate entry *)	
		direntry.dirInfo.cluster := -1;
		direntry.dirInfo.pos := -1;
		res := Ok
	ELSE res := Error
	END
END RemoveDirectoryEntry;

(* AllocateDirectoryCluster - allocates a new cluster for a directory and clears its content *)
PROCEDURE AllocateDirectoryCluster(vol: Volume; directory, lastCluster: LONGINT; VAR newCluster: LONGINT);
VAR i, dummy: LONGINT; data: ARRAY vol.clusterSize OF CHAR;
BEGIN
	IF (directory = 0) & (vol.bpb.FATType # FAT32) THEN (* root of FAT12/16 *)
		(* no clusters can be allocated, but the contents of the virtual cluster are cleared *)
		dummy := GetDirectoryCluster(vol, directory, lastCluster+1, data);
		FOR i := 0 TO vol.clusterSize-1 DO
			IF (i MOD DirEntrySize = 0) THEN data[i] := deLAST
			ELSE data[i] := 0X
			END
		END;
		dummy := PutDirectoryCluster(vol, directory, lastCluster+1, data);
		newCluster := lastCluster+1
	ELSE (* 'normal' directory *)
		newCluster := AllocateCluster(vol, lastCluster);
		FOR i := 0 TO -1 DO
			IF (i MOD DirEntrySize = 0) THEN data[i] := deLAST
			ELSE data[i] := 0X
			END
		END;
		vol.PutBlock(vol, newCluster, data)
	END
END AllocateDirectoryCluster;

(* AssignDirectoryEntry - finds a position in the directory 'direntry.dircluster' where the directory entry can be stored *)
PROCEDURE AssignDirectoryEntry(vol: Volume; VAR direntry: DirEntry; VAR res: INTEGER);
VAR c, p, dc: DirCache; pos, num, dummy: LONGINT;
BEGIN
	IF Trace THEN 
		Kernel.WriteString(moduleName); Kernel.WriteString("AssignDirectoryEntry: "); Kernel.WriteString(direntry.long); Kernel.WriteLn 
	END;
	IF (vol.dirCache.type = dcInvalid) OR (vol.dirCache.entry.dirInfo.dirCluster # direntry.dirInfo.dirCluster) THEN (* build freeList if not cached *)
		EnumerateDirectory(vol, direntry.dirInfo.dirCluster, NIL, NIL)
	END;
	ASSERT(vol.dirCache.entry.dirInfo.dirCluster = direntry.dirInfo.dirCluster);
	IF Detail THEN
		Kernel.WriteString(" Looking in free list for "); Kernel.WriteInt(direntry.dirInfo.num, 0); Kernel.WriteString(" free entries"); Kernel.WriteLn;
		Kernel.WriteString(" directory cache: "); Kernel.WriteLn;
		DumpDirCache(vol)
	END;
	p := NIL; c := vol.dirCache;
	WHILE (c.type # dcSentinel)  & ((c.type # dcFree) OR (c.entry.dirInfo.num < direntry.dirInfo.num)) DO p := c; c := c.next END;
	direntry.dirInfo.cluster := c.entry.dirInfo.cluster; direntry.dirInfo.pos := c.entry.dirInfo.pos;
	IF Detail THEN
		Kernel.WriteString("   found at cluster "); Kernel.WriteInt(direntry.dirInfo.cluster, 0); Kernel.WriteString(", position ");
		Kernel.WriteInt(direntry.dirInfo.pos, 0); Kernel.WriteLn
	END;
	IF (c.type = dcFree) THEN
		(* we have found a slot within the directory *)
		IF Detail THEN Kernel.WriteString("   within directory"); Kernel.WriteLn END;
		IF (direntry.dirInfo.num < c.entry.dirInfo.num) THEN (* some entries remain free *)
			NEW(dc); dc.entry.dirInfo := c.entry.dirInfo; dc.next := c; 
			c.entry.dirInfo.num := c.entry.dirInfo.num - direntry.dirInfo.num;
			c.entry.dirInfo.pos := c.entry.dirInfo.pos + direntry.dirInfo.num*DirEntrySize;
			WHILE (c.entry.dirInfo.pos > vol.clusterSize) DO
				DEC(c.entry.dirInfo.pos, vol.clusterSize DIV DirEntrySize);
				dummy := GetDirectoryCluster(vol, c.entry.dirInfo.dirCluster, c.entry.dirInfo.cluster, NIL)
			END			
		ELSE dc := c
		END
	ELSE (* slot at the end of the directory *)
		IF (c.entry.dirInfo.pos = vol.clusterSize) THEN
			(* this directory does not contain a deLAST mark because the last entry is located at the end of the last cluster of this directory *)
			AllocateDirectoryCluster(vol, c.entry.dirInfo.dirCluster, c.entry.dirInfo.cluster, c.entry.dirInfo.cluster);
			direntry.dirInfo.cluster := c.entry.dirInfo.cluster; direntry.dirInfo.pos := 0; c.entry.dirInfo.pos := 0
		END;
		
		NEW(dc); dc.entry.dirInfo := c.entry.dirInfo; dc.next := c;
	
		IF Detail THEN Kernel.WriteString("   at the end of the directory; pos = "); Kernel.WriteInt(direntry.dirInfo.pos, 0); Kernel.WriteLn END;
		(* allocate new clusters until the new entry has enough free space *)
		pos := c.entry.dirInfo.pos; num := direntry.dirInfo.num;
		WHILE (pos + num*DirEntrySize > vol.clusterSize) DO
			AllocateDirectoryCluster(vol, c.entry.dirInfo.dirCluster, c.entry.dirInfo.cluster, c.entry.dirInfo.cluster);
			DEC(num, (vol.clusterSize-pos) DIV DirEntrySize); c.entry.dirInfo.pos := 0; pos := 0
		END;
		INC(c.entry.dirInfo.pos, num*DirEntrySize)
	END;
	dc.type := dcValid; dc.entry.dirInfo.num := direntry.dirInfo.num;
	IF (p = NIL) THEN vol.dirCache := dc
	ELSE p.next := dc
	END;
	IF Trace THEN
		Kernel.WriteString(" position: "); Kernel.WriteInt(direntry.dirInfo.cluster, 0); Kernel.WriteChar("@");
		Kernel.WriteInt(direntry.dirInfo.pos, 0); Kernel.WriteChar("."); Kernel.WriteInt(direntry.dirInfo.num, 0);
		Kernel.WriteLn;
		IF Detail THEN DumpDirCache(vol) END
	END
END AssignDirectoryEntry;

(** DeleteClusterChain - deletes a cluster chain, starting at 'link', marking all clusters as free *)
PROCEDURE DeleteClusterChain*(vol: Volume; VAR link: LONGINT);
VAR cluster: LONGINT;
BEGIN
	IF (link >=2) & (link <= vol.bpb.CountOfClusters+1) THEN
		REPEAT
			cluster := link;
			link := GetFATEntry(vol, cluster);
			PutFATEntry(vol, cluster, FREE); 
			INC(vol.bpb.FSInfo.FreeCount)
		UNTIL (link = EOC);
		link := NONE
	END
END DeleteClusterChain;

(* WriteShortEntry - writes a short directory entry into the buffer 'buf' at position 'pos' *)
PROCEDURE WriteShortEntry(VAR data: ARRAY OF CHAR; pos: LONGINT; direntry: DirEntry);
VAR k: INTEGER; ft: FATTime;
BEGIN
	IF (direntry.cluster = NONE) THEN direntry.cluster := 0 END;
	FOR k := 0 TO 10 DO data[pos+k] := direntry.short[k] END;
	data[pos+11] := SYSTEM.VAL(CHAR, direntry.attr);
	data[pos+12] := direntry.NTRes;
	ft := TimeOberon2FAT(direntry.creationTime);
	data[pos+13] := CHR(ft.tenth);
	PutUnsignedInteger(data, pos+14, ft.time);
	PutUnsignedInteger(data, pos+16, DateOberon2FAT(direntry.creationDate));
	PutUnsignedInteger(data, pos+18, DateOberon2FAT(direntry.accessDate));
	PutUnsignedInteger(data, pos+20, direntry.cluster DIV 10000H);	(* bits 31-16 *)
	ft := TimeOberon2FAT(direntry.writeTime);
	PutUnsignedInteger(data, pos+22, ft.time);
	PutUnsignedInteger(data, pos+24, DateOberon2FAT(direntry.writeDate));
	PutUnsignedInteger(data, pos+26, direntry.cluster MOD 10000H);	(* bits 15-0 *)
	IF ~(faDirectory IN direntry.attr) THEN PutLongint(data, pos+28, direntry.size)
	ELSE PutLongint(data, pos+28, 0)
	END
END WriteShortEntry;

(** WriteDirectoryEntry - writes a directory entry 'direntry' back to the volume 'vol'. 'res'=Ok indicates success *)
PROCEDURE WriteDirectoryEntry*(vol: Volume; VAR direntry: DirEntry; VAR res: INTEGER);
VAR cluster, d, idx, k, n, pos, t, dummy: LONGINT; unicode: UCSName;
	data: ARRAY vol.clusterSize OF CHAR; chksum: CHAR; dirCache: DirCache; 
BEGIN
	(* wp: direntry.long does not collide with existing long names, 
			valid field: direntry.namechanged, direntry.dircluster valid, 
				if ~direntry.namechanged: direntry.num 
				if direntry.sector # -1 then direntry.pos, direntry.NTRes must be valid
	*)
	res := Ok;
			
	IF direntry.namechanged THEN
		IF (direntry.dirInfo.cluster # -1) THEN 
			RemoveDirectoryEntry(vol, direntry, res);
			IF (res # Ok) THEN RETURN END
		END;
		GetShortName(vol, direntry, unicode, res);
		IF (res # Ok) THEN RETURN END;
		AssignDirectoryEntry(vol, direntry, res);
		IF (res # Ok) THEN RETURN END
	ELSE
		ASSERT((direntry.dirInfo.cluster # -1) & (direntry.dirInfo.pos >= 0) & 
			(direntry.dirInfo.pos < vol.clusterSize) & (direntry.dirInfo.num > 0));
	END;
	
	(* write long name *)
	IF direntry.namechanged & (direntry.dirInfo.num > 1) THEN
		n := direntry.dirInfo.num; cluster := direntry.dirInfo.cluster; pos := direntry.dirInfo.pos;
		dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
		chksum := CheckSum(direntry.short, 0);
		WHILE (n > 1) DO
			IF (n < direntry.dirInfo.num) THEN data[pos] := CHR(n-1) ELSE data[pos] := CHR(40H + n-1) END;
			data[pos+11] := SYSTEM.VAL(CHAR, faLongName);
			data[pos+12] := 0X;
			data[pos+13] := chksum;
			PutInteger(data, pos+26, 0);
			k := 0; idx := (n-2)*13;
			FOR k := 0 TO 4 DO PutInteger(data, pos+1+k*2, unicode[idx+k]) END;
			FOR k := 0 TO 5 DO PutInteger(data, pos+14+k*2, unicode[idx+5+k]) END;
			FOR k := 0 TO 1 DO PutInteger(data, pos+28+k*2, unicode[idx+11+k]) END;
			INC(pos, DirEntrySize);
			IF (pos >= vol.clusterSize) THEN
				cluster := PutDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
				dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
				pos := 0
			END;
			DEC(n)
		END;
		dummy := PutDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data)
	ELSE (* find position of short name entry *)
		n := direntry.dirInfo.num; cluster := direntry.dirInfo.cluster; pos := direntry.dirInfo.pos;
		dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
		WHILE (n > 1) DO
			INC(pos, DirEntrySize);
			IF (pos >= vol.clusterSize) THEN
				cluster := dummy;
				dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
				pos := 0
			END;
			DEC(n)
		END;
	END;
	
	(* write short name *)
	Kernel.GetClock(t, d);
	direntry.writeTime := t;
	direntry.writeDate := d;
	dummy := GetDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
	WriteShortEntry(data, pos, direntry);
	dummy := PutDirectoryCluster(vol, direntry.dirInfo.dirCluster, cluster, data);
	direntry.namechanged := FALSE;
	direntry.modified := FALSE;
	(* update dirCache *)
	IF (direntry.dirInfo.dirCluster = vol.dirCache.entry.dirInfo.dirCluster) THEN
		dirCache := vol.dirCache;
		WHILE (dirCache.entry.dirInfo.cluster # direntry.dirInfo.cluster) OR (dirCache.entry.dirInfo.pos # direntry.dirInfo.pos) DO 
			dirCache := dirCache.next 
		END;
		dirCache.entry := direntry
	END;
	(* sync *)
	Sync(vol)
END WriteDirectoryEntry;

(** CreateDirectory - creates a directory in the directory specified by 'parentDir' and returns the cluster of the 
	new directory, BAD if unsuccessful *)
PROCEDURE CreateDirectory*(vol: Volume; parentDir: Address; name: LongName): Address;
VAR de: DirEntry; cluster, dummy, i, t, d: LONGINT; res: INTEGER; data: ARRAY vol.clusterSize OF CHAR;
BEGIN
	IF Trace THEN
		Kernel.WriteString(moduleName); Kernel.WriteString(" creating directory '"); 
		Kernel.WriteString(name); Kernel.WriteChar("'"); Kernel.WriteLn
	END;
	(* find a cluster for the new directory *)
	cluster := AllocateCluster(vol, NONE);
	IF Detail THEN
		Kernel.WriteString(" data cluster of new directory is "); Kernel.WriteInt(cluster, 0); Kernel.WriteLn
	END;
	(* write directory entry into its parent directory *)
	de.long := name; INCL(de.attr, faDirectory); de.NTRes := 0X; de.size := 0; de.cluster := cluster;
	Kernel.GetClock(t, d); de.creationDate := d; de.creationTime := t; de.accessDate := d;
	de.dirInfo.dirCluster := parentDir; de.dirInfo.cluster := -1; de.namechanged := TRUE;
	WriteDirectoryEntry(vol, de, res);
	IF (res # Ok) THEN RETURN BAD END;
	(* clear the whole new cluster *)
	FOR i := 0 TO vol.clusterSize-1 DO data[i] := deLAST END;
	(* write "." and ".." entries into the new directory, bypass name generation *)
	de.dirInfo.dirCluster := cluster; de.dirInfo.cluster := cluster;
	FOR i := 0 TO 10 DO de.short[i] := " " END;
	de.short[0] := "."; de.dirInfo.num := 1; de.dirInfo.pos := 0;
	WriteShortEntry(data, 0, de);
	de.short[1] := "."; de.cluster := parentDir; de.dirInfo.pos := DirEntrySize;
	WriteShortEntry(data, DirEntrySize, de);
	dummy := PutDirectoryCluster(vol, cluster, cluster, data);
	Sync(vol);
	RETURN de.dirInfo.dirCluster
END CreateDirectory;

(** GetDirectoryName - returns the name of a given directory, identified by its first cluster *)
PROCEDURE UpDirHandler(p: Param; VAR continue: BOOLEAN);
BEGIN
	WITH p: UpDirParam DO
		IF (p.direntry.long = "..") THEN p.upCluster := p.direntry.cluster END;
		p.found := (p.direntry.cluster = p.dirCluster) OR 
			((p.dirCluster = -1) & (p.direntry.long = ".."));	(* during the first pass, we need the '..' entry to find the parent dir *)
		continue := ~p.found
	END
END UpDirHandler;

PROCEDURE FindUpDir(vol: Volume; VAR path: LongName; VAR pos:LONGINT; p: UpDirParam);
VAR dirname: LongName; upcluster, i: LONGINT;
BEGIN
	IF (p.dirCluster = 0) THEN path[pos] := "/"; INC(pos) (* root *)
	ELSE
		upcluster := p.upCluster;
		EnumerateDirectory(vol, upcluster, UpDirHandler, p);
		IF p.found THEN
			IF (p.dirCluster # -1) THEN dirname := p.direntry.long ELSE dirname := "" END;
			p.dirCluster := upcluster;
			FindUpDir(vol, path, pos, p);
			IF (dirname # "") THEN
				i := 0;
				WHILE (i < LEN(path)-2) & (dirname[i] # 0X) DO
					path[pos] := dirname[i];
					INC(pos); INC(i)
				END;
				path[pos] := "/"; INC(pos); path[pos] := 0X
			END	
		ELSE ErrorMsg("Invalid directory link"); SYSTEM.HALT(17)
		END
	END	
END FindUpDir;

PROCEDURE GetDirectoryName*(vol: Volume; cluster: LONGINT; VAR path: LongName);
VAR p: UpDirParam; pos: LONGINT;
BEGIN
	IF (cluster # 0) THEN
		NEW(p); p.dirCluster := -1; p.upCluster := cluster; pos := 0;
		FindUpDir(vol, path, pos, p)
	ELSE 
		path := "/"
	END
END GetDirectoryName;

(** GetDirectorySize - returns the size of a given directory, identified by its first cluster.
	the size is a multiple of the cluster size or, in the case of the root directory of a FAT12/FAT16 volume,
	a multiple of the sector size. *)
PROCEDURE GetDirectorySize*(vol: Volume; cluster: LONGINT): LONGINT;
VAR size: LONGINT;
BEGIN
	size := 0;
	IF (cluster = 0) & (vol.bpb.FATType # FAT32) THEN (* root directory of FAT12/16 *)
		size := vol.bpb.RootDirSectors * vol.blockSize
	ELSE
		IF (cluster = 0) THEN cluster := vol.bpb.RootClus END; (* root directory of FAT32 *)
		size := vol.clusterSize;
		cluster := GetFATEntry(vol, cluster);
		WHILE (cluster # EOC) & (cluster # BAD) DO
			INC(size, vol.clusterSize);
			cluster := GetFATEntry(vol, cluster)
		END
	END;
	RETURN size	
END GetDirectorySize;

(** Helper Functions *)

(** DateFAT2Oberon, DateOberon2FAT, TimeFAT2Oberon, TimeOberon2FAT - conversion between FAT and 
	Oberon date/time values *)

(* DOS formats: 
		date: bits 15-9: count of years from 1980 (0-127)
					8-5: month of year (1-12)
					4-0: day of month (1-31)
					
		time: bits 15-11: hours (0-23)
					10-5: minutes (0-59)
					4-0: 2-second count (0-29)
					additional byte: bits 7-8: count of 0.01 seconds (0-199)
					
	Oberon formats:
		time: bits 16-12: hours
					11-6: minutes
					5-0: seconds
					
		date: 30-9: count of years from 1900
					8-5: month of year
					4-0: day of month
*)
PROCEDURE DateFAT2Oberon*(d: LONGINT): LONGINT;
BEGIN RETURN (d DIV 512 MOD 128 + 80) * 512 + d MOD 512
END DateFAT2Oberon;

PROCEDURE DateOberon2FAT*(d: LONGINT): LONGINT;
BEGIN RETURN (d DIV 512 - 80) MOD 128 * 512 + d MOD 512
END DateOberon2FAT;

PROCEDURE TimeFAT2Oberon*(ft: FATTime): LONGINT;
BEGIN RETURN ft.time DIV 2048 MOD 32 * 4096 + ft.time DIV 32 MOD 64 * 64 + ft.time MOD 32 * 2 + ft.tenth DIV 100
END TimeFAT2Oberon;

PROCEDURE TimeOberon2FAT*(t: LONGINT): FATTime;
VAR ft: FATTime;
BEGIN 
	ft.time := t DIV 4096 MOD 32 * 2048 + t DIV 64 MOD 64 * 32 + t MOD 64 DIV 2;
	ft.tenth := 100 * SHORT(AND(t, 1) MOD 200);
	RETURN ft
END TimeOberon2FAT;

(* AND - bitwise AND *)
PROCEDURE AND(a,b: LONGINT): LONGINT;
BEGIN RETURN SYSTEM.VAL(LONGINT, SYSTEM.VAL(SET, a) * SYSTEM.VAL(SET, b))
END AND;

(* GetCharacters - copies 'count' bytes from 'b' to 's', starting at 'b[ofs]' *)
PROCEDURE GetCharacters(VAR b: ARRAY OF CHAR; ofs: LONGINT; VAR s: ARRAY OF CHAR; count: LONGINT);
VAR i: INTEGER;
BEGIN 
	i := 0; WHILE (i < count) DO s[i] := b[ofs+i]; INC(i) END
END GetCharacters;

(* PutInteger - writes an integer at offset 'ofs' in 'b' which is assumed to be little endian *)
PROCEDURE PutInteger(VAR b: ARRAY OF CHAR; ofs: LONGINT; value: INTEGER);
BEGIN
	b[ofs] := SYSTEM.VAL(CHAR, value MOD 100H);
	b[ofs+1] := SYSTEM.VAL(CHAR, value DIV 100H)
END PutInteger;

(* GetUnsignedInteger - returns an unsigned integer at offset 'ofs' in 'b' which is assumed to be little endian *)
PROCEDURE GetUnsignedInteger(VAR b: ARRAY OF CHAR; ofs: LONGINT): LONGINT;
BEGIN
	RETURN 100H*LONG(ORD(b[ofs+1])) + LONG(ORD(b[ofs]))
END GetUnsignedInteger;	

(* PutUnsignedInteger - writes an unsigned integer at offset 'ofs' in 'b' which is assumed to be little endian *)
PROCEDURE PutUnsignedInteger(VAR b: ARRAY OF CHAR; ofs, value: LONGINT);
BEGIN
	b[ofs] := SYSTEM.VAL(CHAR, value MOD 100H);
	b[ofs+1] := SYSTEM.VAL(CHAR, (value DIV 100H) MOD 100H)
END PutUnsignedInteger;

(* GetLongint - returns a long integer at offset 'ofs' in 'b' which is assumed to be little endian *)
PROCEDURE GetLongint(VAR b: ARRAY OF CHAR; ofs: LONGINT): LONGINT;
BEGIN
	RETURN 1000000H*LONG(ORD(b[ofs+3])) + 10000H*LONG(ORD(b[ofs+2])) + 
		100H*LONG(ORD(b[ofs+1])) + LONG(ORD(b[ofs]))
END GetLongint;	

(* PutLongint - writes a long integer at offset 'ofs' in 'b' which is assumed to be little endian *)
PROCEDURE PutLongint(VAR b: ARRAY OF CHAR; ofs, value: LONGINT);
VAR i : INTEGER;
BEGIN
	FOR i := 0 TO 3 DO b[ofs+i] := SYSTEM.VAL(CHAR, value MOD 100H); value := value DIV 100H END
END PutLongint;

(** QuickFormat - formats a FAT volume *)
PROCEDURE QuickFormat*(vol: Volume);
VAR i, sector, dummy: LONGINT; data: PCharArray;
BEGIN
	vol.unsafe := TRUE; PutFATEntry(vol, 1, EOC);
	FOR i := 2 TO vol.bpb.CountOfClusters+1 DO
		PutFATEntry(vol, i, FREE)
	END;
	WriteVolumeFlags(vol, FALSE, FALSE);
	vol.bpb.FSInfo.NextFree := 2;
	IF (vol.bpb.FATType # FAT32) THEN
		(* clear root directory *)
		NEW(data, vol.blockSize); FOR i := 0 TO vol.blockSize-1 DO data[i] := deLAST END;
		sector := vol.bpb.RsvdSecCnt + (vol.bpb.NumFATs * vol.bpb.FATSz16);
		FOR i := 0 TO (vol.bpb.RootEntCnt DIV (vol.blockSize DIV DirEntrySize))-1 DO
			vol.PutBlock(vol, -(sector+i), data^)
		END
	ELSE
		(* create and clear root directory *)
		PutFATEntry(vol, 2, EOC); (* allocate cluster 2 for the root directory *)
		vol.bpb.RootClus := 2;
		NEW(data, vol.clusterSize);
		FOR i := 0 TO vol.clusterSize-1 DO data[i] := deLAST END;
		dummy := PutDirectoryCluster(vol, vol.bpb.RootClus, vol.bpb.RootClus, data^);
		INC(vol.bpb.FSInfo.NextFree);
		vol.bpb.FSInfo.FreeCount := vol.bpb.CountOfClusters-1
	END;
	Sync(vol);
	(* reset dirCache *)
	vol.dirCache.type := dcInvalid; vol.dirCache.entry.dirInfo.dirCluster := -1; vol.dirCache.next := NIL
END QuickFormat;

(* ErrorMsg - writes an error message into the Kernel log *)
PROCEDURE ErrorMsg(msg: ARRAY OF CHAR);
BEGIN Kernel.WriteString(msg); Kernel.WriteLn
END ErrorMsg;

(* DumpDirCache - writes the contents of the directory cache into the kernel log *)
PROCEDURE DumpDirCache(vol: Volume);
VAR cd: DirCache;
BEGIN
	Kernel.WriteString(" directory cache: "); Kernel.WriteLn;
	cd := vol.dirCache;
	WHILE (cd # NIL) DO
		Kernel.WriteString(" (");
		CASE cd.type OF
		| dcSentinel: Kernel.WriteChar("S")
		| dcFree: Kernel.WriteChar("F")
		| dcValid: Kernel.WriteChar("V")
		| dcInvalid: Kernel.WriteChar("I")
		END;
		Kernel.WriteString("; "); Kernel.WriteInt(cd.entry.dirInfo.dirCluster, 0); Kernel.WriteChar(".");
		Kernel.WriteInt(cd.entry.dirInfo.cluster, 0); Kernel.WriteChar("@"); 
		Kernel.WriteInt(cd.entry.dirInfo.pos, 0); Kernel.WriteChar("."); Kernel.WriteInt(cd.entry.dirInfo.num, 0); 
		Kernel.WriteString(") "); IF (cd.type = dcValid) THEN Kernel.WriteString(cd.entry.long) END;
		Kernel.WriteLn;
		cd := cd.next
	END;
	Kernel.WriteLn
END DumpDirCache;

BEGIN
	NEW(flushBuffer, FlushBufferSize*1024)
END OFSFATVolumes.
